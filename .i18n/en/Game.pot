msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Wed Jul 30 22:52:42 2025\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "The rfl tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "## Summary\n"
"\n"
"`rfl` proves goals of the form `X = X`.\n"
"\n"
"In other words, the `rfl` tactic will close any goal of the\n"
"form `A = B` if `A` and `B` are *identical*.\n"
"\n"
"`rfl` is short for \\\"reflexivity (of equality)\\\".\n"
"\n"
"## Example:\n"
"\n"
"If the goal looks like this:\n"
"\n"
"```\n"
"x + 37 = x + 37\n"
"```\n"
"\n"
"then `rfl` will close it. But if it looks like `0 + x = x` then `rfl` won't work, because even\n"
"though $0+x$ and $x$ are always equal as *numbers*, they are not equal as *terms*.\n"
"The only term which is identical to `0 + x` is `0 + x`.\n"
"\n"
"## Details\n"
"\n"
"`rfl` is short for \\\"reflexivity of equality\\\"."
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "Most levels in this game will require you to prove a mathematical theorem. In the middle of the\n"
"screen, you will see your \"Active Goal\", which includes \"Objects:\" `x: ‚Ñù` and a \"Goal\" `x=x`.\n"
"In later levels, you may also get a \"Assumptions\" line. Your objects and assumptions are what you\n"
"have to work with. In this case, we know that `x` is in  `‚Ñù`, which means `x` is a real number.\n"
"From this, we have to prove our goal, that `x=x`.\n"
"\n"
"The first tactic we will use is the `rfl` tactic. `rfl` stands for \"reflexivity\". `rfl` will solve\n"
"goals when the left side of an equation is the same as the right side, at least up to definitions."
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "Try typing 'rfl' into the text box below, then hit \"Execute\". This should finish the proof."
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "Try `rfl`"
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "You have now finished your first proof in Lean 4! In future levels, you can also use the 'rfl' tactic.\n"
"You can click on the 'rfl' box on the right side to learn more about the 'rfl' tactic.\n"
"\n"
"Click on \"Next\" to go to the next level."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "The rewrite (rw) tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "## Summary\n"
"\n"
"If `h` is a proof of an equality `X = Y`, then `rw [h]` will change\n"
"all `X`s in the goal to `Y`s. It's the way to \\\"substitute in\\\".\n"
"\n"
"## Variants\n"
"\n"
"* `rw [‚Üê h]` (changes `Y`s to `X`s; get the back arrow by typing `\\left ` or `\\l`.)\n"
"\n"
"* `rw [h1, h2]` (a sequence of rewrites)\n"
"\n"
"* `rw [h] at h2` (changes `X`s to `Y`s in hypothesis `h2`)\n"
"\n"
"* `rw [h] at h1 h2 ‚ä¢` (changes `X`s to `Y`s in two hypotheses and the goal;\n"
"get the `‚ä¢` symbol with `\\|-`.)\n"
"\n"
"* `repeat rw [add_zero]` will keep changing `? + 0` to `?`\n"
"until there are no more matches for `? + 0`.\n"
"\n"
"* `nth_rw 2 [h]` will change only the second `X` in the goal to `Y`.\n"
"\n"
"### Example:\n"
"\n"
"If you have the assumption `h : x = y + y` and your goal is\n"
"```\n"
"succ (x + 0) = succ (y + y)\n"
"```\n"
"\n"
"then\n"
"\n"
"`rw [add_zero]`\n"
"\n"
"will change the goal into `succ x = succ (y + y)`, and then\n"
"\n"
"`rw [h]`\n"
"\n"
"will change the goal into `succ (y + y) = succ (y + y)`, which\n"
"can be solved with `rfl`.\n"
"\n"
"### Example:\n"
"\n"
"You can use `rw` to change a hypothesis as well.\n"
"For example, if you have two hypotheses\n"
"```\n"
"h1 : x = y + 3\n"
"h2 : 2 * y = x\n"
"```\n"
"then `rw [h1] at h2` will turn `h2` into `h2 : 2 * y = y + 3`.\n"
"\n"
"## Common errors\n"
"\n"
"* You need the square brackets. `rw h` is never correct.\n"
"\n"
"* If `h` is not a *proof* of an *equality* (a statement of the form `A = B`),\n"
"for example if `h` is a function or an implication,\n"
"then `rw` is not the tactic you want to use. For example,\n"
"`rw [P = Q]` is never correct: `P = Q` is the theorem *statement*,\n"
"not the proof. If `h : P = Q` is the proof, then `rw [h]` will work.\n"
"\n"
"## Details\n"
"\n"
"The `rw` tactic is a way to do \\\"substituting in\\\". There\n"
"are two distinct situations where you can use this tactic.\n"
"\n"
"1) Basic usage: if `h : A = B` is an assumption or\n"
"the proof of a theorem, and if the goal contains one or more `A`s, then `rw [h]`\n"
"will change them all to `B`s. The tactic will error\n"
"if there are no `A`s in the goal.\n"
"\n"
"2) Advanced usage: Assumptions coming from theorem proofs\n"
"often have missing pieces. For example `add_zero`\n"
"is a proof that `? + 0 = ?` because `add_zero` really is a function,\n"
"and `?` is the input. In this situation `rw` will look through the goal\n"
"for any subterm of the form `x + 0`, and the moment it\n"
"finds one it fixes `?` to be `x` then changes all `x + 0`s to `x`s.\n"
"\n"
"Exercise: think about why `rw [add_zero]` changes the term\n"
"`(0 + 0) + (x + 0) + (0 + 0) + (x + 0)` to\n"
"`0 + (x + 0) + 0 + (x + 0)`\n"
"\n"
"If you can't remember the name of the proof of an equality, look it up in\n"
"the list of lemmas on the right.\n"
"\n"
"## Targeted usage\n"
"\n"
"If your goal is `b + c + a = b + (a + c)` and you want to rewrite `a + c`\n"
"to `c + a`, then `rw [add_comm]` will not work because Lean finds another\n"
"addition first and swaps those inputs instead. Use `rw [add_comm a c]` to\n"
"guarantee that Lean rewrites `a + c` to `c + a`. This works because\n"
"`add_comm` is a proof that `?1 + ?2 = ?2 + ?1`, `add_comm a` is a proof\n"
"that `a + ? = ? + a`, and `add_comm a c` is a proof that `a + c = c + a`.\n"
"\n"
"If `h : X = Y` then `rw [h]` will turn all `X`s into `Y`s.\n"
"If you only want to change the 37th occurrence of `X`\n"
"to `Y` then do `nth_rw 37 [h]`."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "## Summary\n"
"\n"
"`repeat t` repeatedly applies the tactic `t`\n"
"to the goal. You don't need to use this\n"
"tactic, it just speeds things up sometimes.\n"
"\n"
"## Example\n"
"\n"
"`repeat rw [add_zero]` will turn the goal\n"
"`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\n"
"into the goal\n"
"`a = b`.\n"
"\"\n"
"\n"
"TacticDoc nth_rw \"\n"
"## Summary\n"
"\n"
"If `h : X = Y` and there are several `X`s in the goal, then\n"
"`nth_rw 3 [h]` will just change the third `X` to a `Y`.\n"
"\n"
"## Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `nth_rw 2 [two_eq_succ_one]`\n"
"will change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\n"
"will change the goal to `succ 1 + succ 1 = 4`."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "## Summary\n"
"\n"
"If `h : X = Y` and there are several `X`s in the goal, then\n"
"`nth_rw 3 [h]` will just change the third `X` to a `Y`.\n"
"\n"
"## Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `nth_rw 2 [two_eq_succ_one]`\n"
"will change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\n"
"will change the goal to `succ 1 + succ 1 = 4`."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "The second tactic we will look at is the rewrite tactic. This tactic is how you \"substitute in\"\n"
"a value for something you know is equal. If you have an assumption `h: A=B`, and your goal is to\n"
"prove something about `A`, you can replace `A` with `B`, since they are equal.\n"
"\n"
"In this level, the goal is to prove `2 * y = 2 * (x + 7)`. You also have an assumption `h: y = x + 7`.\n"
"Writing `rw[h]` will rewrite `y` as `x + 7` in the goal.\n"
"\n"
"Also note that the `rw` tactic will automatically attempt the `rfl` tactic after it rewrites, so if\n"
"after the rewrite the goal is of the form `X = X`, it will automatically be solved."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "Try using `rw [h]` to solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "Try `rw [h]`"
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "You now know the two most basic tactics in Lean! Again, you can click on `rw` on the right hand side\n"
"to see more about the tactic.\n"
"\n"
"Click on \"Next\" to go to the next level!"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "The `intro` and `exact` tactics"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "## Summary\n"
"\n"
"Intro introduces a new hypothesis and changes your goal. If you have a goal of the form `P ‚Üí Q`,\n"
"`intro h` will change the goal to `Q` and create a new hypothesis `h : P`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `x = 1 ‚Üí x + x = 2`, `intro h` will create the hypothesis `h: x = 1`, and change the\n"
"goal to `x + x = 2`.\n"
"\n"
"## Other usage\n"
"\n"
"The `intro` tactic also works with goals using `‚àÄ` (\\\"for all\\\"). If your goal is of the form `‚àÄ x : T, P`,\n"
"`intro x` will create a new variable `x : T`, and change the goal to `P`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `‚àÄ x : Nat, x ‚â• 0`, `intro x` will create a variable `x : Nat`, and change the goal\n"
"to `x ‚â• 0`."
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "## Summary\n"
"\n"
"If the goal is a statement `P`, then `exact h` will solve the goal if `h` is a proof of `P`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `x + 5 = 10`, and you have a hypothesis `h: x + 5 = 10`, then `exact h` will solve\n"
"the goal.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `x ‚¨ù y = 0 ‚Üî x ‚üÇ y`, and you have a theorem `dot_zero_iff_perp` that states the same\n"
"thing, `exact dot_zero_iff_perp` will solve the goal.\n"
"\n"
"## exact? tactic\n"
"\n"
"`exact` has a variation, `exact?`, that is very useful. If your goal seems very obvious, and if you\n"
"believe that there is a theorem or hypothesis that is exactly the same as your goal, `exact?` will\n"
"attempt to fill in an `exact` tactic. This way, you don't have to memorize the exact statement of\n"
"every theorem in order to finish a proof.\n"
"However, with great power comes great responsibility, and using `exact?` too often can obscure how\n"
"a proof actually works, and can lead you to being more confused than when you started."
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "In this level, we will introduce two tactics: `intro`, and `exact`\n"
"Our goal is to prove that for any proposition (a True/False statement) `P`, we know that `P ‚Üí P`.\n"
"This means that `P` implies `P`.\n"
"\n"
"To explain what implication means more rigorously, if we know that `P ‚Üí Q`, whenever `P` is True, we\n"
"now know that `Q` must also be True. A computer scientist can consider a proof that `P ‚Üí Q` as a function\n"
"taking proofs of `P` to proofs of `Q`. In Lean, this means that we take an arbitrary proof of `P`,\n"
"say `h: P` and we must construct a proof of `Q` from it.\n"
"\n"
"### Intro\n"
"This idea is exatly what the `intro` tactic does. If the goal is of the form `P ‚Üí Q`, `intro h` will\n"
"create a new hypothesis `h: P`, and change the goal into `Q`.\n"
"\n"
"### Exact\n"
"The exact tactic is the other tactic you will need to solve this level. If you have a hypothesis that\n"
"is exactly the same as the goal, the exact tactic will solve the goal. For example, if your goal is\n"
"`P`, and you have a hypothesis `h: P`, `exact h` will solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "First use `intro` to give yourself a new assumption and simplify the goal"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "Try `intro h`"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "Now use `exact` to solve the goal"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "Try `exact h`"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "You now know how to use the `intro` and `exact` tactics!"
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "The `constructor` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "## Summary\n"
"\n"
"The constructor tactic splits the goal into multiple parts. This is helpful for goals that are\n"
"difficult to solve all at once, like \"and\" (`‚àß`) and \"if and only if\" (`‚Üî`).\n"
"\n"
"## Example\n"
"\n"
"If we have the goal `P ‚àß Q`, `constructor` will change the goal into two goals: `P` and `Q`.\n"
"\n"
"## Example\n"
"\n"
"If we have the goal`P ‚Üî Q`, `constructor` will change the goal into two goals: `P ‚Üí Q`, and `Q ‚Üí P`."
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "In this level we will learn `constructor` in the context of logical 'and' (‚àß).\n"
"Our goal is to prove `P ‚àß Q`, \"P and Q\", given hypotheses `p: P` and `q: Q`.\n"
"\n"
"### Constructor:\n"
"\n"
"The `constructor` tactic works by splitting up the goal. If you have a goal `P ‚àß Q`, the tactic makes\n"
"progress by turning this one goal into two goals: to prove `P` and to prove `Q`. Constructor also\n"
"works similarly for `‚Üî` \"if and only if\" goals."
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "Try using `constructor` to split up the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "Both remaining goals are exactly your hypotheses. What tactic can solve the goals?"
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "Try `exact p`"
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "Try `exact q`"
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "You can now prove goals by splitting them into multiple steps with the `constructor` tactic!"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "The `unfold` and `apply` tactics"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "## Summary\n"
"\n"
"If we have some object or function with some definition, `unfold object` will rewrite the object\n"
"with its definition everywhere. Lean often unfolds terms automatically, but some tactics and definitions\n"
"are not unfolded automatically. The `unfold` tactic also helps make it easier to take the next steps.\n"
"\n"
"## Example:\n"
"\n"
"If you have a goal `(P ‚Üí Q) ‚Üí (¬¨ Q ‚Üí ¬¨ P)`, with `¬¨ P` (\\\"Not\\\" P) being defined as `P ‚Üí False`,\n"
"using `unfold Not` will change the goal to `(P ‚Üí Q) ‚Üí ((Q ‚Üí False) ‚Üí (P ‚Üí False))`"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "## Summary\n"
"\n"
"If `t : P ‚Üí Q` is a proof that $P \\implies Q$, and `h : P` is a proof of `P`,\n"
"then `apply t at h` will change `h` to a proof of `Q`. The idea is that if\n"
"you know `P` is true, then you can deduce from `t` that `Q` is true.\n"
"\n"
"If the *goal* is `Q`, then `apply t` will \\\"argue backwards\\\" and change the\n"
"goal to `P`. The idea here is that if you want to prove `Q`, then by `t`\n"
"it suffices to prove `P`, so you can reduce the goal to proving `P`.\n"
"\n"
"### Example:\n"
"\n"
"`succ_inj x y` is a proof that `succ x = succ y ‚Üí x = y`.\n"
"\n"
"So if you have a hypothesis `h : succ (a + 37) = succ (b + 42)`\n"
"then `apply succ_inj at h` will change `h` to `a + 37 = b + 42`.\n"
"You could write `apply succ_inj (a + 37) (b + 42) at h`\n"
"but Lean is smart enough to figure out the inputs to `succ_inj`.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `a * b = 7`, then `apply succ_inj` will turn the\n"
"goal into `succ (a * b) = succ 7`."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "## Summary\n"
"\n"
"`intros` acts very similar to the `intro` tactic, except it allows you to introduce many new\n"
"hypotheses/variables at once. `intros h1 h2 h3` essentially acts as `intro h1; intro h2; intro h3;`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `P ‚Üí Q ‚Üí (‚àÄ x : Nat, R ‚Üí (x = 5))`, `intros p q x r` will create hypotheses `p: P`,\n"
"`q: Q`, `r: R`, and a variable `x: Nat`, and change the goal to `x = 5`."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "## Summary\n"
"\n"
"`Not` is the logical negation. In Lean, `¬¨ P` is defined as `P ‚Üí False`.\n"
"When you see `¬¨ P` in a goal or hypothesis, you can use `unfold Not` to\n"
"replace it with `P ‚Üí False`.\n"
"\n"
"## Example\n"
"\n"
"If you have a goal `¬¨ P`, using `unfold Not` will change it to `P ‚Üí False`.\n"
"This often makes it easier to work with using `intro` and other tactics."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "In this level, we will learn the `unfold` and `apply` tactics. Our goal is to prove `(P ‚Üí Q) ‚Üí (¬¨ Q ‚Üí ¬¨ P)`,\n"
"which looks very messy and difficult, but it can be slowly unfolded and broken down into simple steps.\n"
"\n"
"The first tactic we will need is `unfold`. You may notice the `¬¨` symbol appearing multiple times in\n"
"the goal. This symbol means \"Not\", so `¬¨P` means \"not P\", or that P is false. In Lean, this is\n"
"encoded as `P ‚Üí False`.\n"
"\n"
"### Unfold\n"
"The `unfold` tactic will unfold definitions. Think of it as a big `rw` tactic that rewrites something\n"
"with it's definition everywhere. In this level, `unfold Not` will replace all the `¬¨ P`s with `P ‚Üí False`.\n"
"\n"
"We know how to deal with statements of the form `P ‚Üí Q` in the goal, but what happens if we have them\n"
"as hypotheses? In this case, we will need the `apply` tactic.\n"
"\n"
"### Apply\n"
"The `apply` tactic applies a hypothesis of the form `P ‚Üí Q` to the goal. If your goal is `Q`, and\n"
"you have a hypothesis `h: P ‚Üí Q`, `apply h` will change the goal to `P`.\n"
"\n"
"### Combining hypotheses\n"
"Another way to use `h: P ‚Üí Q` hypotheses is that if you also have another hypothesis  `h2: P`,\n"
"`h h2` will be a proof of `Q`. So, if you have these two hypotheses, and your goal is `Q`, `exact h h2`\n"
"will solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Try using `unfold Not` to unfold the definition of `¬¨`."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Now, since there is a hypothesis also with a `¬¨` symbol, `unfold Not at *` will unfold\n"
"everywhere!"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Try `unfold Not`"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Now, since you goal is of the form `P ‚Üí Q`, the `intro` tactic may help."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Try `intro h1`"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "You can still use the `intro` tactic because the goal is still of the form `P ‚Üí Q`"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Try `intro h2`"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Try `intro h3`"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Now, try the `apply` tactic. Remember that if your goal is `Q`, you can use `apply h` when\n"
"h is a hypothesis or proof that `P ‚Üí Q`. You can also solve the level with one carefully worded\n"
"`exact` statement if you combine your hypotheses."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Try `apply h2`"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Again, try the `apply` tactic to change the goal. You can also solve the level with one carefully worded\n"
"`exact` statement if you combine your hypotheses."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Try `apply h1`"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Try `exact h3`"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "This theorem shows that a statement `P ‚Üí Q` implies its contrapositive `¬¨Q ‚Üí ¬¨P`. In fact, these\n"
"two statements are the same, and you can prove `(P ‚Üí Q) ‚Üî (¬¨ Q ‚Üí ¬¨ P)`\n"
"\n"
"Also, instead of writing intro three times, you can write `intros h1 h2 h3`, and that will be the\n"
"same as `intro h1; intro h2; intro h3`."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "The `cases'` and `exfalso` tactics"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "## Summary\n"
"\n"
"If `h` is a proof (for example a hypothesis), then `cases' h with...` will break the\n"
"proof up into the pieces used to prove it.\n"
"\n"
"## Example\n"
"\n"
"If `h : P ‚à® Q` is a hypothesis, then `cases' h with hp hq` will turn one goal\n"
"into two goals, one with a hypothesis `hp : P` and the other with a\n"
"hypothesis `hq : Q`.\n"
"\n"
"## Example\n"
"\n"
"If `h : False` is a hypothesis, then `cases' h` will turn one goal into no goals,\n"
"because there are no ways to make a proof of `False`! And if you have no goals left,\n"
"you have finished the level.\n"
"\n"
"\n"
"## Example\n"
"\n"
"If `h : ‚àÉ (a : ‚Ñù), a * a = 0` is a hypothesis, thatn `cases' h with a ha` will create a variable\n"
"`a : Nat` and a hypothesis `ha : a * a = 0`"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "## Summary\n"
"\n"
"`exfalso` changes any goal to `False` this works because proving `False` is a contradiction and can\n"
"thus prove anything else. Mathematically, this means that for any proposition `P`, `False ‚Üí P`.\n"
"\n"
"## Example\n"
"\n"
"If you have a hypothesis `h: False`, and a goal `Q`, `exfalso; exact h` will solve the goal`"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "This level introduces the `cases'` and `exfalso` tactics. The goal of this level is to prove `(P ‚àß ¬¨ P) ‚Üí Q`.\n"
"This proof is similar to a proof by contradiction. The first part of the implication, `P ‚àß ¬¨ P`, is\n"
"a contradiction, so it can prove any proposition `Q`.\n"
"\n"
"### Cases'\n"
"The `cases'` tactic is very important in Lean. It allows you to split any object or hypothesis into\n"
"cases. In this level, we will eventually have an and statement as a hypothesis. If we have `h: P ‚àß Q`,\n"
"`cases' h with hL hR` will create two hypotheses: `hL: P`, and `hR: Q`. If you have an object `x` that\n"
"can be split into cases, `cases' x with c1 c2` will split `x` into cases called `c1` and `c2`.\n"
"\n"
"### Exfalso\n"
"The `exfalso` tactic is also useful in this level. It simply changes the goal to `False`. This works\n"
"because if you can prove `False`, you have a contradiction, and can thus prove any statements. For\n"
"example, if you have a hypothesis `h: False`, and a goal `Q`, `exfalso; exact h` will solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "You have two main options here. Note that you have a statement of the form `P ‚Üí Q`, so there\n"
"is a tactic we know that can simplify the goal. Also, we have a `¬¨` character, so unfolding that\n"
"could also be helpful"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "Try `intro h`"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "Since the `¬¨` symbol is in a hypothesis now, instead of the goal, in order to unfold it you\n"
"need to do `unfold Not at h`, where you replace `h` with the name of your hypothesis. `unfold Not\n"
"at *` will also unfold it everywhere."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "Try `unfold Not at h`"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "Now, use the `cases'` tactic to split up your and statement hypothesis."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "Try `cases' h with h1 h2`"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "It would be nice if our goal was `False` here."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "Try `exfalso`"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "Try `apply h2`"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "Try `exact h1`"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "You now know most of the basics for working with logic in Lean! The remaining levels in the tutorial\n"
"world will move away from pure logic, but many of the tactics used already will still be essential."
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "The `linarith` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "## Summary\n"
"The `linarith` tactic simplifies the goal by using the hypotheses. It works well on linear inequalities\n"
"and equalities. It works by looking for contradictions, although the actual algorithmic implementation\n"
"is very complicated.\n"
"\n"
"## Example\n"
"\n"
"If you have a bunch of hypotheses like h1 : a < b, h2 : b <= c, h3 : c = d and a goal of a < d,\n"
"then linarith will solve it. Linarith knows how to combine linear relations: it knows a ton of\n"
"results about how to put inequalities together and will close such goals."
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "The `linarith` tactic aims to simplify the process of proofs. Specifically, it solves certain kinds\n"
"of linear equalities and inequalities. It attempts to solve or simplify the goal using the hypotheses\n"
"and certain properties of the numbers you are working with."
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "In this level, simply trying `linarith` should solve the level."
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "Try `linarith`"
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "Linarith is very useful to simplify goals involving linear terms."
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "The `simp` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "### Summary\n"
"\n"
"The `simp` tactic tries to simplify the goal, and will solve it if possible. It acts similar to the\n"
"`rw` tactic, although it is able to rewrite with many different statements many times in order to\n"
"simplify the goal. `simp` will try to use all the theorems available if not told explicitly what\n"
"theorems to use.\n"
"\n"
"Using `simp only [tactic1, tactic2, ...]` will simplify only using the theorems listed.\n"
"\n"
"### Example\n"
"\n"
"If your goal is something simple like `0 + 0 = 0`, `simp` will know enough about the natural numbers\n"
"to solve the goal.\n"
"\n"
"### Example\n"
"\n"
"If your goal is `(d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h`, which seems\n"
"complicated, but you only need to use associativity and commutativity of addition,\n"
"`simp only [add_assoc, add_left_comm, add_comm]` will solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "The `simp` tactic aims to simplify your goal. Often if a goal seems very complicated, or uses\n"
"definitions that need to be unfolded, the `simp` tactic will make progress.\n"
"\n"
"`simp` is not a flawless tool, and there are many simple statements it cannot prove, although when\n"
"used correctly, it can be very useful.\n"
"\n"
"In this level, your goal is to prove an equality about certain elements in a \"Group\". A group is a\n"
"mathematical object where elements in a group can be multiplied together in a way that \"makes sense\".\n"
"Examples of groups involve the real numbers, integers, invertible square matrices of a specific size,\n"
"and many more. `simp` knows many theorems about groups, and is able to simplify and solve most\n"
"simple statements about them.\n"
"\n"
"In this level, `a b c` are all elements of G, `1` is the multiplicative identity of G, and `a‚Åª¬π` is\n"
"the multiplicative inverse of `a`. You can see that both sides of the equation will cancel out to `b`,\n"
"but there is an easy way to prove that they are equal."
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "Just typing `simp` will solve the goal"
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "Try `simp`"
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "`simp` will be very useful when solving simple equations in future worlds. You can always\n"
"read more about it by clicking on it on the right."
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "The `use` tactic and your first theorem"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "## Summary\n"
"\n"
"The `use` tactic makes progress with goals which claim something *exists*.\n"
"If the goal claims that some `x` exists with some property, and you know\n"
"that `x = 37` will work, then `use 37` will make progress.\n"
"\n"
"Because `a ‚â§ b` is notation for \\\"there exists `c` such that `b = a + c`\\\",\n"
"you can make progress on goals of the form `a ‚â§ b` by `use`ing the\n"
"number which is morally `b - a` (i.e. `use b - a`)\n"
"\n"
"Any of the following examples is possible assuming the type of the argument passed to the `use` function is accurate:\n"
"\n"
"- `use 37`\n"
"- `use a`\n"
"- `use a * a + 1`"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "le_iff_exists_add is a proof that `a ‚â§ b ‚Üî ‚àÉ (c : ‚Ñï), a = b + c`.\n"
"\n"
"The reason for the name is that two numbers are less than or equal to each other if and only if\n"
"there exists a number that you can add to the smaller one to make them equal."
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "In this level, the goal is to prove `x ‚â§ 1 + x`. This requires understanding how to prove statements\n"
"about inequalities. We can define the `‚â§` symbol so that `a ‚â§ b` means `‚àÉ (c : ‚Ñï), b = a + c`. In\n"
"other words, a is less than or equal to b if and only if there exists a natural number c where\n"
"b = a + c. In this level, we have decided to use the natural numbers, although the statement is\n"
"clearly also true when working with real numbers. This is because the theorem \"le_iff_exists_add\"\n"
"does not work with the real numbers, so the proof would be slightly different.\n"
"\n"
"We have this statment as a theorem, \"le_iff_exists_add\".\n"
"\n"
"However, note that this theorem will rewrite the goal to have a `‚àÉ` symbol. In this case, we have to\n"
"find a number that satisfies a certain property. Once you find such a number, you can use the `use`\n"
"tactic.\n"
"\n"
"`use c` changes the goal from the form `‚àÉ x, Property(x)` to `Property(c)`. This allows you to solve\n"
"`‚àÉ` goals, but you need to first find a valid example, which may take some planing ahead."
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "Try using the new theorem! Since it is a proof of `‚Üî`, the rewrite tactic should work!"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "Try `rw[le_iff_exists_add]`"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "What number should you use here to make the statement true?"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "Try `use 1`"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "You now have a simple linear equation. What tactic can solve linear equations and prove\n"
"equalities?"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "Try `linarith`"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "Now on to the last level in the tutorial world!"
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "The `induction'` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "## Summary\n"
"\n"
"If `n : ‚Ñï` is an object, and the goal mentions `n`, then `induction' n with d hd`\n"
"attempts to prove the goal by induction on `n`, with the inductive\n"
"variable in the successor case being `d`, and the inductive hypothesis being `hd`.\n"
"\n"
"### Example:\n"
"If the goal is\n"
"```\n"
"0 + n = n\n"
"```\n"
"\n"
"then\n"
"\n"
"`induction' n with d hd`\n"
"\n"
"will turn it into two goals. The first is `0 + 0 = 0`;\n"
"the second has an assumption `hd : 0 + d = d` and goal\n"
"`0 + succ d = succ d`.\n"
"\n"
"Note that you must prove the first\n"
"goal before you can access the second one."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "'add_succ' is a proof that `n + Nat.succ m = Nat.succ (n + m)`.\n"
"\n"
"The reason for the name is that the theorem proves that adding the successor of a number is equal to\n"
"the successor of addind that number."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "The `induction'` tactic is a powerful tool to help you to prove statments involving natural numbers.\n"
"It splits a proof into two cases: a base case and an inductive step. The base case is the smallest\n"
"natural number you need to prove the proof for. The inductive step proves the theorem for all other\n"
"numbers. In the inductive step, you can assume the theorem holds for some value `d`, and must then\n"
"prove that it holds for `d + 1`, also written as `Nat.succ d`, the successor of `d`. Induction can\n"
"also be used to prove theorems about objects indexed my natural numbers, such as vectors whose\n"
"dimension can be described by a natural number.\n"
"\n"
"The syntax for the `induction'` tactic is `induction' n with d hd`. As long as `n` is an arbirtary\n"
"natural number in the proof, this will do induction on `n`, where `d` is the number you assume the\n"
"theorem holds for in the inductive step, and `hd` is the induction hypothesis you will get.\n"
"\n"
"This level also uses a new theorem: `add_succ`. `add_succ` is a proof that\n"
"`n + Nat.succ m = Nat.succ (n + m)`, for any `n, m : ‚Ñï`."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "First, perform induction on `n`."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "Try `induction' n with n h`"
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "Base case: prove 0 + 0 = 0."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "Try `simp`"
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "Inductive step: use add_succ and the induction hypothesis."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "Try `simp [Nat.add_succ, h]`"
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "## Summary\n"
"You have now finished Tutorial World! Now, you can move on to Vector Space world.\n"
"\n"
"The future worlds will be more challenging than this one, and will use less hints. However, if you're\n"
"stuck on how a tactic or theorem works, you can always read what they do on the right, or return to\n"
"Tutorial World for more review!\n"
"\n"
"Click \"Leave World\" to return to the main menu."
msgstr ""

#: Game.Levels.TutorialWorld
msgid "Tutorial World"
msgstr ""

#: Game.Levels.TutorialWorld
msgid "Welcome to the tutorial world! This world is designed to indroduce you to Lean 4.\n"
"\n"
"In this world, we start with proving 'x=x', and then move on to solve basic logic problems and\n"
"simple theorems about the natural numbers.\n"
"\n"
"If you already know how to use Lean 4, you can skip this world, although we recommend playing through it.\n"
"\n"
"Click start to begin solving your first level!"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "Welcome to Vector Space World!"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "## Welcome to Vector Space World!\n"
"\n"
"In this world, you'll build up the basic theory of vector spaces through formal proofs in Lean.\n"
"\n"
"### What You'll Learn\n"
"\n"
"Vector spaces are fundamental structures in linear algebra. You will learn:\n"
"\n"
"- **Vector Space Definition**: A vector space V over a field K with four key axioms\n"
"- **Zero Properties**: How multiplication by zero scalars and zero vectors behaves  \n"
"- **Inverse Operations**: Understanding scalar multiplication by -1\n"
"- **Subspaces**: Subsets of vector spaces that preserve vector space structure\n"
"\n"
"### The Mathematical Foundation\n"
"\n"
"We define a vector space `V` over a field `K` as an abelian group with four fundamental axioms:\n"
"\n"
"- **Distributivity over vector addition:** `a ‚Ä¢ (x + y) = a ‚Ä¢ x + a ‚Ä¢ y`\n"
"- **Distributivity over scalar addition:** `(a + b) ‚Ä¢ x = a ‚Ä¢ x + b ‚Ä¢ x`  \n"
"- **Associativity:** `(a * b) ‚Ä¢ x = a ‚Ä¢ (b ‚Ä¢ x)`\n"
"- **Identity:** `1 ‚Ä¢ x = x`\n"
"\n"
"In this game, `VectorSpace K V` is built on Mathlib's robust `Module K V` over a field, which provides standard mathematical notation and many helpful theorems.\n"
"\n"
"### Getting Started\n"
"\n"
"Note that to write the scalar multiplication symbol `‚Ä¢`, type `\\smul`.\n"
"\n"
"This introductory level uses a trivial proof to get you comfortable with the interface. \n"
"\n"
"Ready to begin your journey into vector spaces? Let's prove our first statement!"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "Perfect! You've completed the introduction to Vector Space World.\n"
"\n"
"In the next level, you'll dive into proving real theorems about vector spaces, starting with zero scalar multiplication.\n"
"\n"
"Click 'Next Level' to continue!"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Vector space intro, zero scalar multiplication"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "## Summary\n"
"The `symm` tactic stands for symmetry of equality. It shows that if we know `a = b`, then `b = a`.\n"
"\n"
"## Example\n"
"If your goal is `a = b`, `symm` will change the goal to `b = a`.\n"
"\n"
"## Example\n"
"If you have a hypothesis `h: a = b`, `symm at h` will change the hypothesis to `h: b = a`.\n"
"\n"
"## Example\n"
"If you have a theorem `add_dist: ‚àÄ a b c, (a + b) * c = a * c + b * c`, and a goal `2 * x + 5 * x = y`,\n"
"`rw[(add_dist 2 5 x).symm]` will change the goal to `(2 + 5) * x = y`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "## Vector Space Definition\n"
"\n"
"We define a vector space `V` over a field `K` as an abelian group with four key axioms. \n"
"In this game, `VectorSpace K V` is built on Mathlib's `Module K V` over a field, which already contains \n"
"all the vector space properties:\n"
"\n"
"```\n"
"abbrev VectorSpace (K V : Type) [Field K] [AddCommGroup V] := Module K V\n"
"```\n"
"\n"
"The four fundamental vector space axioms are:\n"
"- **Distributivity over vector addition:** `a ‚Ä¢ (x + y) = a ‚Ä¢ x + a ‚Ä¢ y`\n"
"- **Distributivity over scalar addition:** `(a + b) ‚Ä¢ x = a ‚Ä¢ x + b ‚Ä¢ x`  \n"
"- **Associativity:** `(a * b) ‚Ä¢ x = a ‚Ä¢ (b ‚Ä¢ x)`\n"
"- **Identity:** `1 ‚Ä¢ x = x`\n"
"\n"
"This educational approach lets us use standard mathematical terminology while leveraging Mathlib's robust\n"
"`Module`, `Field`, and `AddCommGroup` definitions, which provide notation such as `-a` and `a‚Åª¬π`, and include\n"
"many helpful theorems that we will not need to prove ourselves.\n"
"\n"
"Note that to write the `‚Ä¢` character, type\n"
"\"\\smul\".\n"
"\n"
"Also, note that there is some strange `inst‚Ä†` text in your objects. This simply means that your objects\n"
"are instances of certain classes, for example that K V is a vector space.\n"
"\n"
"## Goal for this level\n"
"\n"
"In this level, you'll prove that multiplying a vector by the zero scalar (`0 : K`) results in the\n"
"zero vector (`0 : V`). This is going to be a slightly involved proof, so it is important to get an\n"
"understanding of the proof before beginning to write it.\n"
"\n"
"The first step of a normal proof would be writing `0 ‚Ä¢ w` as `(0 + 0) ‚Ä¢ w`, then using distributivity\n"
"to get it as `0 ‚Ä¢ w + 0 ‚Ä¢ w`. Lastly, cancelling out a `0 ‚Ä¢ w` on each side gets `0 = 0 ‚Ä¢ w`.\n"
"\n"
"However, this proof relies on our assumptions and constructs the goal from them. This can be done in\n"
"Lean, however, it requires using the `have` tactic, and is unnescessarily complex. In Lean, proofs are\n"
"often done backwards, working from the goal and creating the hypotheses.\n"
"\n"
"Doing the proof backwards thus must first involve adding `0 ‚Ä¢ w` to both sides of the goal, undoing\n"
"distributivity, then cancelling out some zeros.\n"
"\n"
"### add_right_cancel\n"
"\n"
"To use cancellation of addition, we need a new theorem, `add_right_cancel`. This theorem is a proof\n"
"that `a + b = c + b ‚Üí a = c`. Since your goal is of the form `a = c`, `apply add_right_cancel` will\n"
"change the goal to `a + ?b = c + ?b`. However, you want to be able to write the value of `?b`, but\n"
"in this case, Lean doesn't know what value you want to add. You can tell Lean what to add to the\n"
"equation by `apply add_right_cancel (b := ????)`, replacing the question marks with whatever you\n"
"want to add.\n"
"\n"
"### zero_add\n"
"\n"
"We also need to know some basic theorems about addition. For both the scalars and vectors, adding any\n"
"vector to `0` will result in that vector. Simply `rw [zero_add]` will show this.\n"
"\n"
"### symm\n"
"\n"
"You will also need the `symm` tactic. `symm` stands for symmetry of equality, and it can be used to\n"
"change goals of the form `a = b` to `b = a`. `symm at h` will also change a hypothesis `h: a = b` to\n"
"`h: b = a`. However, neither of these uses are needed in this level. You may\n"
"notice that if `h: a = b` is a hypothesis, rw[h] will rewrite all `a`s to `b`s. What if you want to\n"
"rewrite all `b`s to `a`s, you can instead do `rw[h.symm]`.\n"
"\n"
"Also note that when the theorem has a `‚àÄ` symbol, as in `‚àÄ a b : S, a + b = b + a`, you need to\n"
"specify what `a` and `b` you mean to use before using `.symm`. For example, you would have to write\n"
"`rw[(h 2 3).symm]`.\n"
"\n"
"One last hint is that when writing `0`, you often want to specify which zero you are talking about.\n"
"We know that the natural numbers, for example, has a `0`, but so do the Field K and the Abelian Group\n"
"V, and those `0`s are different. To specify which `0` you are talking about, write `(0 : K)` or `(0 : V)`.\n"
"\n"
"### Note on simp and linarith\n"
"\n"
"In this world, we are primarilly proving simple statements about vector spaces. This is exactly what\n"
"the `simp` and `linarith` tactics are meant to do. In fact, the `simp` tactic alone would be able to\n"
"solve the first three levels of this world. Because of this, you will not be able to use those tactics\n"
"in this world."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "A vector space is a space over a field K with an abelian group V. In this game, `VectorSpace K V` \n"
"is an educational alias for Mathlib's `Module K V` over a field. It has four main properties:\n"
"- Distributivity over vector addition,\n"
"- Distributivity over scalar addition,\n"
"- Associativity of scalar multiplication,\n"
"- Identity scalar acting as identity.\n"
"\n"
"These properties can be found in the theorems tab as \"smul_add\", \"add_smul\", \"mul_smul\", and \"one_smul\",\n"
"as well as the educational versions \"smul_add_explicit\", \"add_smul_explicit\", etc."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "This is a proof that `0 ‚Ä¢ w = 0`, or that scaling any vector by `0` gives the zero vector.\n"
"\n"
"It is called \"zero_smul_v\", since you perform scalar multiplication by zero. The \"v\" means that it is\n"
"scalar multiplication of a vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "`add_right_cancel` is a proof that `a + b = c + b ‚Üí a = c`. You can tell Lean what to add to the\n"
"equation by `apply add_right_cancel (b := ????)`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "`add_left_cancel` is a proof that `a + b = a + c ‚Üí b = c`. You can tell Lean what to add to the\n"
"equation by `apply add_left_cancel (a := ????)`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "`smul_add` is one of the axioms of a vector space. It is a proof that if we know `vs : VectorSpace K V`,\n"
"then `‚àÄ (a : K) (x y : V), a ‚Ä¢ (x + y) = a ‚Ä¢ x + a ‚Ä¢ y`. It can be considered as right distributivity\n"
"of scalar multiplication"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "`add_smul` is one of the axioms of a vector space. It is a proof that if we know `vs : VectorSpace K V`,\n"
"then `‚àÄ (a b : K) (x : V), (a + b) ‚Ä¢ x = a ‚Ä¢ x + b ‚Ä¢ x`. It can be considered as left distributivity\n"
"of scalar multiplication."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "‚àÄ (a b : K) (x : V), (a * b) ‚Ä¢ x = a ‚Ä¢ (b ‚Ä¢ x)\n"
"`mul_smul` is one of the axioms of a vector space. It is a proof that if we know `vs : VectorSpace K V`,\n"
"then `‚àÄ (a b : K) (x : V), (a * b) ‚Ä¢ x = a ‚Ä¢ (b ‚Ä¢ x)`. It can be considered as associativity of scalar\n"
"multiplication."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "`one_smul` is one of the axioms of a vector space. It is a proof that if we know `vs : VectorSpace K V`,\n"
"then `‚àÄ (x : V), (1 : K) ‚Ä¢ x = x`. It can be thought of as `1` being a multiplicative identity not\n"
"only in `K`, but also through scalar multiplication in `V`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "`symm` is a proof that `a = b` if and only if `b = a`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "`zero_add` is a proof that `0 + x = x`. This holds whether `x` is in `K` or `V`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "`add_zero` is a proof that `x + 0 = x`. This holds whether `x` is in `K` or `V`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "In any vector space V over K, the scalar 0 multiplied by any vector gives the zero vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Remember, we are trying to prove this backwards. The last step in the normal proof was to cancel out 0 ‚Ä¢ w from both sides, so what should the first step of the backwards proof be? Use add_right_cancel to add 0 ‚Ä¢ w to both sides."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Try `apply add_right_cancel (b := (0 : K) ‚Ä¢ w)`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Now use the distributivity property add_smul in reverse. We want to write (0 + 0) ‚Ä¢ w as 0 ‚Ä¢ w + 0 ‚Ä¢ w. Remember to use .symm to reverse the direction."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Try `rw[(add_smul (0 : K) (0 : K) w).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Now simplify the scalars using zero_add: 0 + 0 = 0."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Try `rw[zero_add]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Finally, simplify the right side using zero_add: 0 + 0 ‚Ä¢ w = 0 ‚Ä¢ w."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Try `rw[zero_add]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "You have now proven your first theorem about vector spaces! One note: if you want to use\n"
"one of the theorems you prove in one level in another level, the syntax will often be\n"
"`theorem_name K V theorem_args`. This lets Lean know what vector space you are working with."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Multiplying by the zero vector"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "We just proved that multiplying by the zero scalar gives the zero vector. Now, we will show that multiplying by the zero vector also gives the zero vector.\n"
"\n"
"## The Mathematical Idea\n"
"\n"
"This proof mirrors the previous level but uses the other distributivity property (smul_add instead of add_smul).\n"
"\n"
"## Proof Strategy\n"
"\n"
"The forward proof would be: a ‚Ä¢ 0 = a ‚Ä¢ (0 + 0) = a ‚Ä¢ 0 + a ‚Ä¢ 0, then cancel a ‚Ä¢ 0 from both sides.\n"
"The backward proof: add a ‚Ä¢ 0 to both sides, then use distributivity in reverse, then simplify.\n"
"\n"
"## Tactics Needed\n"
"\n"
"The proof is very similar to the last level, and requires no new tactics. You can look at the previous level for inspiration and syntax help."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "This is a proof that `a ‚Ä¢ 0 = 0`, or that scaling the zero vector by any scalar gives the zero vector.\n"
"\n"
"It is called \"smul_zero_v\", since you perform scalar multiplication by the zero vector. The \"v\" means that it is\n"
"scalar multiplication of a vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "In any vector space V over K, any scalar a multiplied by the zero vector gives the zero vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Start by adding a ‚Ä¢ 0 to both sides using add_right_cancel, just like in the previous level."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Try `apply add_right_cancel (b := a ‚Ä¢ (0 : V))`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Use smul_add in reverse to write a ‚Ä¢ (0 + 0) as a ‚Ä¢ 0 + a ‚Ä¢ 0. This is the distributivity of scalar multiplication over vector addition."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Try `rw[(smul_add a (0 : V) (0 : V)).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Simplify 0 + 0 = 0 in the argument to the scalar multiplication."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Try `rw[zero_add]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Finally, simplify the right side: 0 + a ‚Ä¢ 0 = a ‚Ä¢ 0."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Try `rw[zero_add]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Scaling by -1"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "This is a proof that `-1 ‚Ä¢ v = -v`, that multiplying by the -1 scalar gives the inverse vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "We now understand scaling by `0` very well. We also have an axiom that scaling by `1`\n"
"acts as the identity. The next step is to see what scaling by `-1` does. Intuitively, it should\n"
"cancel out the vector scaled by `1`, so it should be the additive inverse of the vector.\n"
"\n"
"The goal of the level is to prove this.\n"
"\n"
"A few hints that could help:\n"
"The defining property of `-v` is that `-v + v = 0`. The `simp` tactic can use this. Try to use this\n"
"in your proof.\n"
"You can also use the theorems proven in previous levels.\n"
"\n"
"### Difficulty with `one_smul`\n"
"You may eventually try to rewrite a vector `v` as `1 ‚Ä¢ v` in this level. However, trying\n"
"`rw[(one_smul v).symm]` may run into errors. This is because `one_smul v` only takes an element of `V`\n"
"as input, so Lean doesn't know which field \"K\" to use to get the \"1\" from. To fix this, try\n"
"`one_smul K v` to tell Lean which \"K\" you are using.\n"
"\n"
"### `neg_add_self` theorem\n"
"In order to work with negatives, we also have the theorem `neg_add_self`. This is a proof that `-x + x = 0`.\n"
"Similarly to `zero_add`, this theorem works in both K and V. This allows you to cancel out negatives."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "`neg_add_self` is a proof that \"-x + x = 0. This holds whether x is in K or V."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "`neg_add_self` is a proof that \"-x + x = 0. This holds whether x is in K or V."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "In any vector space V over K, multiplying a vector by -1 gives its additive inverse."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Start by adding v to both sides to cancel out the -v on the right. This transforms our goal into showing (-1) ‚Ä¢ v + v = -v + v."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try `apply add_right_cancel (b := v)`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "We need to rewrite the second v as 1 ‚Ä¢ v. Use nth_rw to target only the second occurrence of v (the one being added, not the one being scaled)."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try `nth_rw 2 [(one_smul K v).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Now factor out the v using add_smul in reverse: (-1) ‚Ä¢ v + (1) ‚Ä¢ v = (-1 + 1) ‚Ä¢ v."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try `rw[(add_smul (-1 : K) (1 : K) v).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Simplify the scalar: -1 + 1 = 0."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try `rw[neg_add_self]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Simplify the right side: -v + v = 0."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try `rw[neg_add_self]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Now we have 0 ‚Ä¢ v = 0, which we proved in Level 1. Use the zero_smul_v theorem."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try `exact zero_smul_v K V v`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "We now have many theorems relating to vector spaces! In the next levels, we will introduce\n"
"the idea of a \"subspace\"."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Zero must belong"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Now that we understand more about vector spaces, let's define what a subspace is.\n"
"Intuitively, a subspace is a subset of a vector space that can be considered as a vector space itself.\n"
"We define this as a subset `W : Set V` that is nonempty, is closed under addition, and is closed under scalar multiplication.\n"
"\n"
"### The `obtain` tactic\n"
"A new tactic will help us solve problems with subspaces. While not necessary, and this tactic can\n"
"even be completely replaced by the `cases'` tactic, it will simplify your proofs greatly. The `obtain`\n"
"tactic essentially acts as repeating `cases'`. In this level, it has two main uses. First, if `hw : isSubspace W`\n"
"is a hypothesis, then `obtain ‚ü®h1, h2, h3‚ü© := hW` will split the definition into the three parts,\n"
"labeled h1, h2, and h3. The other important use for `obtain` is if you have a hypothesis `hW : W.Nonempty`,\n"
"then `obtain ‚ü®w, hw‚ü© := hW` will give you a `w : V`, and a hypothesis `hw : w ‚àà W`. The \"‚ü®\"\n"
"character is written with \"\\langle\", and the \"‚ü©\" character is written with \"\\rangle\".\n"
"\n"
"### Subspace contains zero\n"
"One of the basic properties of a subspace is that it must be nonempty. In fact, every subspace must\n"
"contain the zero vector. This is because for any vector in a subspace, you can multiply it by the zero\n"
"scalar while still remaining in the subspace, which wil result in the zero vector. In this level, we\n"
"formally prove this result."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "A subspace is a subset of a vector space that acts similarly to a vector space itself. It has three\n"
"main properties:\n"
"- Nonempty: a subspace cannot be empty\n"
"- Closure under addition: adding any two elements of a subspace should remain in that subspace\n"
"- Closure under scalar multiplication: scaling any vector in a subspace should remanin in that subspace\n"
"\n"
"Subspaces are formalized by having the `isSubspace` proposition, which simply combines the three\n"
"properties into one proposition."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "## Summary\n"
"The `obtain` tactic works very similar to repeating the `cases'` tactic. The `obtain` tactic splits a\n"
"statement into cases, and allows you to name each case. Instead of splitting into two cases, like the\n"
"`cases'` tactic, `obtain` can split into as many cases as necessary. The syntax looks like\n"
"`obtain ‚ü®h1, h2, h3‚ü© := h`.\n"
"\n"
"## Example\n"
"If `hw : isSubspace W` is a hypothesis, then `obtain ‚ü®h1, h2, h3‚ü© := hW` will split the definition\n"
"into three parts, labeled h1, h2, and h3.\n"
"\n"
"## Example\n"
"If you have a hypothesis `hW : W.Nonempty`, where `W : Set V` is a subset of `V`, then\n"
"`obtain ‚ü®w, hw‚ü© := hW` will give you a `w : V`, and a hypothesis `hw : w ‚àà W`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "This is a proof that any subspace contains the zero vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "This is a proof that any subspace contains the zero vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Start by expanding the subspace definition using obtain. This will give you the three properties: nonempty, closed under addition, and closed under scalar multiplication."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Try `obtain ‚ü®h1, h2, h3‚ü© := hW`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "The nonempty property h1 means there exists some element in W. Use obtain to extract this element."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Try `obtain ‚ü®w, hw‚ü© := h1`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "We want to show 0 ‚àà W, but we know that 0 = 0 ‚Ä¢ w (from Level 1). Rewrite the goal using this fact."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Try `rw [(zero_smul_v K V w).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Now apply the scalar multiplication closure property h3. Since w ‚àà W and subspaces are closed under scalar multiplication, 0 ‚Ä¢ w ‚àà W."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Try `apply h3`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Finally, provide the proof that w ‚àà W, which we have from our obtain step."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Try `exact hw`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level06
msgid "Negatives in Subspace"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level06
msgid "The last theorem we will prove in Vector Space World is that subspaces contain the additive inverses of each of their elements. \n"
"\n"
"## The Mathematical Idea\n"
"\n"
"If x ‚àà W and W is a subspace, then -x ‚àà W. This follows because -x = (-1) ‚Ä¢ x, and subspaces are closed under scalar multiplication.\n"
"\n"
"## Proof Strategy\n"
"\n"
"1. Break down the subspace definition using obtain\n"
"2. Introduce the universal quantifier (‚àÄ) using intros\n"
"3. Rewrite -x as (-1) ‚Ä¢ x using the theorem from Level 3\n"
"4. Apply scalar multiplication closure\n"
"\n"
"The proof combines ideas from the previous level with our theorem about -1 scaling."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level06
msgid "This is a proof that if a subspace contains a vector `x`, it also contains `-x`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level06
msgid "First, break down the subspace definition to access the closure properties."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level06
msgid "Try `obtain ‚ü®h1, h2, h3‚ü© := hW`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level06
msgid "Introduce the universal quantifier: we need to show this holds for any x and any proof that x ‚àà W."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level06
msgid "Try `intros x hx`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level06
msgid "Rewrite -x as (-1) ‚Ä¢ x using our theorem from Level 3. This connects negation to scalar multiplication."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level06
msgid "Try `rw [(neg_one_smul_v K V x).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level06
msgid "Apply the scalar multiplication closure property h3. Since x ‚àà W, we have (-1) ‚Ä¢ x ‚àà W."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level06
msgid "Try `apply h3`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level06
msgid "Provide the proof that x ‚àà W, which is our hypothesis hx."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level06
msgid "Try `exact hx`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level06
msgid "You have now completed Vector Space World! The theorems proven here will be very helpful\n"
"in future worlds. You can now move on to World 2: Linear Independence and Span World!"
msgstr ""

#: Game.Levels.VectorSpaceWorld
msgid "Vector Space World"
msgstr ""

#: Game.Levels.VectorSpaceWorld
msgid "Welcome to Vector Space World! \n"
"\n"
"In this world, you'll build up the basic theory of vector spaces through formal proofs in Lean.\n"
"\n"
"You will learn the fundamental axioms that define vector spaces and prove important properties about vector addition, scalar multiplication, and the zero vector.\n"
"\n"
"**Note:** If this introduction page appears blank or incomplete, please click 'Start' and go directly to Level 1, which contains a comprehensive introduction to vector spaces.\n"
"\n"
"Click start to begin your first level!"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "Welcome to Linear Independence and Span World!"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "## Welcome to Linear Independence and Span World!\n"
"\n"
"This world introduces the fundamental concepts of linear independence, linear dependence, and the span of a set of vectors.\n"
"\n"
"### What You'll Learn\n"
"\n"
"Linear independence and span are central concepts in linear algebra that help us understand:\n"
"\n"
"- **Linear Combinations**: How to express vectors as sums of scaled vectors\n"
"- **Linear Independence**: When vectors don't depend on each other\n"
"- **Linear Dependence**: When one vector can be written in terms of others  \n"
"- **Span**: The set of all possible linear combinations of a given set\n"
"- **Bases and Dimensions**: Minimal spanning sets and vector space structure\n"
"\n"
"### Mathematical Foundation\n"
"\n"
"A **linear combination** of vectors v‚ÇÅ, v‚ÇÇ, ..., v‚Çô is any expression of the form:\n"
"```\n"
"a‚ÇÅ ‚Ä¢ v‚ÇÅ + a‚ÇÇ ‚Ä¢ v‚ÇÇ + ... + a‚Çô ‚Ä¢ v‚Çô\n"
"```\n"
"where a‚ÇÅ, a‚ÇÇ, ..., a‚Çô are scalars from the field K.\n"
"\n"
"A set of vectors is **linearly independent** if the only way to make a linear combination equal zero is by setting all coefficients to zero.\n"
"\n"
"The **span** of a set S is the collection of all possible linear combinations of vectors from S.\n"
"\n"
"### What Makes This World Challenging\n"
"\n"
"The proofs in this world are more sophisticated than previous worlds. You'll work with:\n"
"- Set theory and subset relationships\n"
"- Existential and universal quantifiers  \n"
"- Proof by cases and contradiction\n"
"- Complex logical structures\n"
"\n"
"### Getting Started\n"
"\n"
"This introductory level uses a simple proof to prepare you for the mathematical rigor ahead.\n"
"\n"
"The real mathematical journey begins in Level 2 with linear combinations!"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "Excellent! You're ready to tackle the challenging world of linear independence and span.\n"
"\n"
"In Level 2, you'll dive into the formal definition of linear combinations and prove your first theorem about them.\n"
"\n"
"The mathematical adventure begins now - click 'Next Level'!"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "Linear Combinations"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "The first level of this world will introduce the definition of a linear combination. Let's\n"
"say we want to express that some vector `x` is a linear combination of some set `S ‚äÜ V`. This means\n"
"that there is some number of elements in `S`, that after some scalar multiplication, sums to `x`.\n"
"Since infinite sums are difficult (and sometimes impossible) to work with, we can't simply sum over\n"
"all of `S`. Instead, we take some smaller subset `s : Finset V`, with `‚Üës ‚äÜ S`, and sum over that.\n"
"Note here the `‚Üë` character. This simply takes our finite set `s`, which is a `Finset`, and treats it\n"
"as a `Set`.\n"
"\n"
"Once we have the set we are summing over `s`, we need to also multiply the elements of `s` by scalars.\n"
"We do this with a function `f : V ‚Üí K`, where each element of `s` gets mapped to the scalar we multiply by.\n"
"Now, we are able to understand the definition of linear combinations:\n"
"\n"
"```\n"
"def is_linear_combination (S : Set V) (x : V) : Prop :=\n"
"  ‚àÉ (s : Finset V) (f : V ‚Üí K), (‚Üës ‚äÜ S) ‚àß (x = Finset.sum s (fun v => f v ‚Ä¢ v))\n"
"```\n"
"\n"
"### The Goal\n"
"The goal of this level is to prove that if `v ‚àà S`, then `v` is a linear combination of `s`. This can\n"
"be done simply by summing over the set `{v}`, with only multiplying by the scalar 1.\n"
"\n"
"### Defining functions\n"
"In this level, we need to use the `use` tactic to specify a function `f`. A very versatile way of doing\n"
"this is with the `fun` keyword. This allows you to write the function, and for Lean to accept it as a function.\n"
"For example, to write `f(x) = x¬≤`, we can say `fun x => x * x`.\n"
"\n"
"### The return of the `simp` tactic\n"
"Since the levels in this world will become more difficult than in the last world, you are again allowed\n"
"to use the `simp` tactic. It is able to solve most simple equalities with vectors, and helps greatly\n"
"when trying to simplify properties of sets."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "`is_linear_combination` is how we define a vector `x` to be a linear combination of some set `S ‚äÜ V`.\n"
"To say this, we write `is_linear_combination K V S x`. It is defined by the existance of some set `s ‚äÜ S`,\n"
"and a function `f : V ‚Üí K`, such that `x` is the sum over `s` of `f(v) ‚Ä¢ v`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "`Finset.sum` is how we difine summing over a set. It uses Mathlib's `Finset` Type, which means that we\n"
"can only sum over arbitrary finite sets. The syntax is as follows: With a additive group or field `K`, some Type `T`,\n"
"some `s : Finset T`, and some `f : T ‚Üí K`, `Finset.sum s (fun x => f x)` sums `f x` over all `x ‚àà s`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "`linear_combination_of_mem` is a proof that if `v ‚àà S` then `is_linear_combination K V S v`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "If `v ‚àà S`, then `v` is a linear combination of `S`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "It is generally helpful to unfold definitions you are unfamiliar with"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "Try `unfold is_linear_combination`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "Now, you have to specify what set you are summing over"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "Try `use {v}`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "Now, you have to specify the function you are using to map vectors to the scalars they will be multiplied by"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "Try `use (fun x => 1)`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "This is an and statement, so you could use the `constructor` tactic and work from there. Instead, try `simp` and see what happens"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "Try `exact hv`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "You have completed your first proof in Linear Independence and Span World!"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "Introducing Span"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "In this level, we will introduce the span of a set of vectors. The span of a set of vectors is simply\n"
"all the vectors that can be written as a linear combination of that set. In Lean, we define it as such:\n"
"\n"
"```\n"
"def span (S : Set V) : Set V :=\n"
"  { x : V | is_linear_combination K V S x }\n"
"```\n"
"\n"
"### The Goal\n"
"The goal of this level is to prove that if a vector `v ‚àà S`, then `v` is in the span of `S`. This feels\n"
"very similar to the previous level, so you can use the theorem proved in the previous level in this one."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "`mem_span_of_mem` is a proof that if a vector `v ‚àà S`, then `v ‚àà span K V S`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "The span of a set of vectors `S`, denoted `span K V S` is the set of all vectors that are a linear\n"
"combination of `S`. It is represented in Lean as\n"
"\n"
"``` { x : V | is_linear_combination K V S x } ```"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "If `v ‚àà S`, then `v ‚àà span K V S`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "Once again, we have a definition we are unfamiliar with in the goal. Try to change it to terms\n"
"we are familiar with"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "Try `unfold span`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "The `simp` tactic is very helpful when dealing with sets."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "This seems familiar"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "Try 'exact linear_combination_of_mem K V hv`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "You could have actually solved this level with simply an `exact linear_combination_of_mem K V hv`.\n"
"This is because the way set-builder notation is defined in lean is that `x ‚àà { x : V | is_linear_combination K V S x }`\n"
"is the same as saying `is_linear_combination K V S x`. The `simp` tactic only directly shows you this."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "Monotonicity of Span"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "### The Goal\n"
"In this level, you will prove that the span of a set of vectors is monotonic. That is, that if `A ‚äÜ B`,\n"
"then `span K V A ‚äÜ span K V B`. To understand why this is true, think about any arbitrary vector `x ‚àà span K V A`.\n"
"`x` must be a linear combination of vectors of `A`, and since all those vectors are in `A`, they must\n"
"also be in `B`, so `x` is a linear combination of vectors in `B`, and must be in `span K V B`.\n"
"\n"
"### `subset_trans`\n"
"To solve this level, we need a theorem `subset_trans`. This theorem shows that subsets are transitive,\n"
"so if you have `h1 : A ‚äÜ B` and `h2 : B ‚äÜ C`, then `subset_trans h1 h2` is a proof that `A ‚äÜ C`. This can be proven quite easily, but since we have\n"
"a theorem already proving it, why not use it?"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "`subset_trans` is a proof that subsets are transitive. The syntax is that if you have `h1 : A ‚äÜ B`\n"
"and `h2 : B ‚äÜ C`, then `subset_trans h1 h2` is a proof that `A ‚äÜ C`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "`span_mono` is a proof that the span of sets is monotonic. Simply, this means that if you have `h : A ‚äÜ B`,\n"
"then `span_mono K V h` is a proof that `span K V A ‚äÜ span K V B`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "The span of sets is monotonic. Simply, this means that if you have `h : A ‚äÜ B`,\n"
"then `span_mono K V h` is a proof that `span K V A ‚äÜ span K V B`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "First, I would take an arbitrary `x`, then unfold and simplify our goals."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "Try `intro x hxA`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "Try `unfold span at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "Try `unfold is_linear_combination at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "Try `simp at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "Now, what information can we get out of ¬´{hxA}¬ª?"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "Try `obtain ‚ü®s, hsA, f, h1, h2‚ü© := hxA`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "What set should we be summing over?"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "Try `use s`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "Try `exact subset_trans hsA hAB`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "What function should we be using?"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "Try `use f`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "The idea of unfolding all the definitions and then using `simp at *` is very helpful. I\n"
"would recommend using this sequence of tactics at the start of most levels.\n"
"\n"
"Also, note that `use f` closed the goal. This is because the `use` tactic attempts `rfl` after it\n"
"executes, similarly to `rw`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "Linear Independence"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "This level will introduce linear independence of a set of vectors. A set `S` of vectors is linearly\n"
"independent if no vector in `S` can be written as a linear combination of the others. Equivalently,\n"
"we can say that `S` is linearly independent if any combination of vectors in `S` summing to `0` must\n"
"be all `0`s. In Lean, it is written as:\n"
"\n"
"```\n"
"def linear_independent_v (S : Set V) : Prop :=\n"
"‚àÄ (s : Finset V) (f : V ‚Üí K),\n"
"(‚Üës ‚äÜ S) ‚Üí (Finset.sum s (fun v ‚Ü¶ f v ‚Ä¢ v) = 0) ‚Üí (‚àÄ v ‚àà s, f v = 0)\n"
"```\n"
"\n"
"Note that we use the same idea as in linear combinations, where we have a Finset `s`, a function\n"
"mapping vectors to the scalars that multiply those vectors, and use `Finset.sum`.\n"
"\n"
"### The Goal\n"
"The goal of this level is to prove that the empty set is linearly independent. This makes sense,\n"
"because there are no vectors in the empty set that can be scaled be a non-zero factor."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "This is a proof that the empty set is linearly independent."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "`linear_independent_v` means that a set of vectors is linearly independent. To say a set `S : Set V`\n"
"is linearly independent, we write `linear_independent_v K V S`. This is defined that any finite set of scalar\n"
"multiples of vectors in `S` that sum to `0` must all be `0`. It is written in Lean as\n"
"\n"
"```\n"
"def linear_independent_v (S : Set V) : Prop :=\n"
"‚àÄ (s : Finset V) (f : V ‚Üí K),\n"
"(‚Üës ‚äÜ S) ‚Üí (Finset.sum s (fun v ‚Ü¶ f v ‚Ä¢ v) = 0) ‚Üí (‚àÄ v ‚àà s, f v = 0)\n"
"```\n"
"\n"
"Note that we use `Finset` here, which means that even though `S` can be infinite, `s` must be finite."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "The empty set is linearly independent."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "Try `unfold linear_independent_v`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "Here, we have many ‚àÄ and ‚Üí statements in the goal. Try to move these variables to the hypotheses"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "Try `intros s f hs sum_zero v hv`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "We now have a hypothesis `¬´{hv}¬ª: v ‚àà ¬´{_s}¬ª` and `¬´{hs}¬ª : `‚Üë¬´{_s}¬ª ‚äÜ ‚àÖ`. This may be a contradiction,\n"
"so maybe we can chang eour goal to `False` and prove that"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "Try `exfalso`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "If you can figure out a way to get a proof of the form `¬´{v}¬ª ‚àà ‚àÖ`, that statement is equivalent\n"
"to `False`, so an `exact` statement could work. (Actually, `exact?` should solve the goal)"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "Try `exact hs hv`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "We won't prove it in this game (although it isn't too difficult), but any set containing\n"
"a single vector is also linearly independent."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "Linear Independence of Subsets"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "### The Goal\n"
"In this level, we will prove that subsets of linearly independent sets are also linearly independent.\n"
"This is because if any set of nonzero vectors in the smaller set were to sum to zero, then the same set\n"
"of vectors would be in the larger set, and also must sum to zero.\n"
"\n"
"### The `have` tactic\n"
"One very powerful tactic that you have not learned yet is the `have` tactic. This tactic allows you\n"
"to create your own hypotheses, as long as you can prove that they are correct. This allows you to take\n"
"more of a \"forward reasoning\" approach to Lean proofs, as you can create new hypotheses from your old\n"
"ones, slowly changing your hypotheses to the goal, instead of changing your goal to the hypotheses.\n"
"The syntax for a `have` statement is `have h : 0 ‚Ä¢ v = 0 := zero_smul_v v`. The `h` is the name of your\n"
"new hypothesis, `0 ‚Ä¢ v = 0` is the statement of the hypothesis, and `zero_smul_v v` is the proof of the\n"
"new hypothesis. You can read more about the tactic on the right side of the screen."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "## Summary\n"
"`have` allows you to create your own statements. It allows you to prove hypotheses which you can then\n"
"use to prove the goal.\n"
"\n"
"The syntax for `have` is `have h : Hypothesis := proof` to create a hypothesis `h : Hypothesis` where\n"
"`proof` is a proof of the hypothesis\n"
"\n"
"## `by`\n"
"`by` allows you to write muli-line proofs. When your have statement is a lemma that will take multiple\n"
"steps to prove, replacing your proof with `by` will add a subgoal to prove your hypothesis. All the\n"
"lines proving this hypothesis will need to be indented.\n"
"\n"
"Using `by` can also only be done in editor mode, which can be accessed by clicking the \"<\\>\" button in the\n"
"top right.\n"
"\n"
"## Example\n"
"If you want to have a hypothesis `h : 0 ‚Ä¢ v = 0`, then `have h : 0 ‚Ä¢ v = 0 := zero_smul_v v` will create\n"
"that hypothesis\n"
"\n"
"## Example\n"
"If you want to prove a lemma `simple_lemma : ‚àÄ (a b c n : ‚Ñï+), n > 2 ‚Üí a ^ n + b ^ n ‚â† c ^ n`, then\n"
"`have simple_lemma : ‚àÄ (a b c n : ‚Ñï+), n > 2 ‚Üí a ^ n + b ^ n ‚â† c ^ n := by` will change the goal to\n"
"proving your lemma, and once you prove it, you can then use the lemma."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "`subset_linear_independent` is a proof that if `A` is a linearly independent set, and we have `B ‚äÜ A`,\n"
"then `B` is also linearly independent. The syntax is as follows: if `hBsubA : B ‚äÜ A` and `hA : linear_independent_v K V A`\n"
"are hypotheses, then `subset_linear_independent hBsubA hA` is a proof that `linear_independent_v K V B`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "If `A` is a linearly independent set, and we have `B ‚äÜ A`, then `B` is also linearly independent."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "Try `unfold linear_independent_v at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "Try `intros s f hsB sum_zero v hv`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "Look at hA. When all the assumptions are met, we get `f v = 0`, which is our goal. This means\n"
"that if we are able to get all of the assumptions as hypotheses, we can solve with an exact statement.\n"
"However, we still don't have a hypothesis that `‚Üës ‚äÜ A`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "Try `have hsA : ‚Üës ‚äÜ A := subset_trans hsB hBsubA`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "Now, the level can be solved with a (slightly long) `exact` statement"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "Try `exact hA s f hsA sum_zero v hv`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Supersets Span the Whole Space"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Now that we know some properties of subsets, we can work on a property of supersets. This level is a\n"
"proof that if `A` spans the whole space, then any `B ‚äá A` also spans the whole space\n"
"\n"
"### The Goal\n"
"We have three sets, and three hypotheses. We have sets `A` and `B`, which are the set and superset we\n"
"are working with. We also have the set `T`, which is the entire space `V`. The reason we are using `T`\n"
"instead of `V` is that `T` is an object of the type `Set V`, which is the same type as `span K V A` or\n"
"`span K V B`. We can't compare these spans with `V`, but we can compare them with `T`. This also means\n"
"we need a hypothesis  (hT : ‚àÄ (x : V), x ‚àà T), which means that any element of `V` is also in `T`.\n"
"The other two hypotheses simply state that `B` is a superset of `A`, and that the span of `A` is `T`.\n"
"The goal is to prove that the span of `B` is also `T`.\n"
"\n"
"### `Set.eq_of_subset_of_subset`\n"
"When working with sets, a very useful theorem is `Set.eq_of_subset_of_subset`. This theorem shows that\n"
"two sets are equal if and only if they are subsets of each other. So, if you have a goal of the form\n"
"`A = B`, `apply Set.eq_of_subset_of_subset` will change the goal into two goals: `A ‚äÜ B`, and `B ‚äÜ A`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "`superset_span_full` is a proof that if a set `A` spans the whole space `V`, then any superset of `A`\n"
"also spans `V`. The syntax requires a set `T : Set V` with the property `hT: ‚àÄ (x : V), x ‚àà T`, so that\n"
"`T` is a subset that is actually the entire space. With other hypotheses `hA : T = span K V A`, and\n"
"`hAsubB : A ‚äÜ B`, then `superset_span_full` is a proof that `T = span K V B`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "`Set.eq_of_subset_of_subset` is a proof that `A = B` if and only if `A ‚äÜ B` and `B ‚äÜ A`. If you have\n"
"a goal of the form `A = B`, `apply Set.eq_of_subset_of_subset` will change the goal into two goals:\n"
"`A ‚äÜ B`, and `B ‚äÜ A`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "If a set $A$ spans the whole space $V$, then any superset of $A$ also spans $V`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `apply Set.eq_of_subset_of_subset`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `rw [hA]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `exact span_mono K V hAsubB`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `intros x _ssg`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `exact hT x`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "The next three levels in this world will be much more difficult. The next level can be\n"
"thought of as a \"boss level\", and the last two levels can be extra optional challenges. Try to plan\n"
"out your proofs before writing them."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Uniqueness of linear combinations"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "This is the \"boss level\" of the Linear Independence and Span World. This level is a\n"
"proof that in a linearly independent set, linear combinations are unique. There are also a few new tactics\n"
"and multiple new theorems you should use.\n"
"\n"
"### The Goal\n"
"In this level, we have 5 objects and 6 hypotheses about those objects. We have the set `S : Set V`,\n"
"which is the linearly independent set we are working with. We also have `s` and `f`, which are the set\n"
"and function we are summing over to get the first linear combination, and `t` and `g` are the second\n"
"linear combination. We have `hs : linear_independent_v K V S`, which states that `S` is linearly independent,\n"
"`hs : ‚Üës ‚äÜ S` and `ht : ‚Üët ‚äÜ S`, which state that `s` and `t` are both in `S`, so are valid linear\n"
"combinations of `S`. We know `hf0 : ‚àÄ v ‚àâ s, f v = 0` and a similar `hg0`, which state that both functions\n"
"are zero outside of their domain. This helps us prove `f = g`, since otherwise we wouldn't know what\n"
"the values of `f` and `g` would be outside of `s` and `t`. Lastly, we have `heq : Finset.sum s (fun v => f v ‚Ä¢ v) = Finset.sum t (fun v => g v ‚Ä¢ v)`,\n"
"which shows that the two linear combinations are equal. We then must pove that `f = g`\n"
"\n"
"### The `specialize` tactic\n"
"The `specialize` tactic can be thought of as the opposite of `use`. While `use` helps specify a value\n"
"for a `‚àÉ` in the goal, `specialize` specifies a value for a `‚àÄ` in a hypothesis. For example, if you\n"
"have a hypothesis `h : ‚àÄ v : V, v ‚Ä¢ 1 = v`, and you have a vector `x : V`, then `specialize h x` will\n"
"change `h` to `h : x ‚Ä¢ 1 = x`. `specialize` also works if `h` is an implication. If `h1 : P ‚Üí Q` is a\n"
"hypothesis, and `h2 : P` is a proof of `P`, then `specialize h1 h2` will change `h2` to `h2 : Q`.\n"
"\n"
"### The `by_cases` tactic\n"
"The `by_cases` tactic helps you prove something by cases. If you want to prove a statement about vectors\n"
"in `V`, but you want to split into cases where `v = 0` or `v ‚â† 0`, `by_cases hv : v = 0` will split the\n"
"goal into two subgoals: one where you have a hypothesis `hv : v = 0`, and another where you have a hpyothesis\n"
"`hv : v ‚â† 0`.\n"
"\n"
"### The `funext` tactic\n"
"The `funext` tactic lets you prove statements about functions. It works similarly to the `intro` tactic,\n"
"where you introduce an arbitrary object, but instead of introducing from a `‚àÄ` statment, it works if\n"
"you have a goal of the form `f = g`, where `funext x` will change the goal to the form `f x = g x`, and\n"
"give you an arbitrary `x` in the domain of `f` and `g`.\n"
"\n"
"### New theorems\n"
"This level requires multiple new theorems, particularly ones about Finsets and sums. There are two theorems\n"
"about vector spaces that can be proven quite easily, but they are still nice to have without needing\n"
"to prove them first. Instead of explaining them all here, you can look at them on the right side of\n"
"the screen. The new theorems are: `coe_union`, `union_subset`, `sub_smul`, 'sum_add_distrib', 'sum_sub_distrib',\n"
"`subset_union_left`, `subset_union_right`, `sum_subset`, `sub_eq_zero`, and `not_mem_union`.\n"
"If you need more theorems, you can either prove them in lemmas, or if you want, you can go to the world\n"
"select menu and turn \"Rules\" to \"none\", which should allow you to use any tactic or theorem in Lean.\n"
"\n"
"### Proof overview\n"
"If you look at the hypotheses you have, the most important ones are that S is linearly independent and\n"
"that the two sums are equal. When you have a statement that a set is linearly independent, it is often\n"
"very helpful to try to find the correct set and function to sum over, then try to satisfy the assumptions\n"
"to prove that the function must be zero. Since the goal is to prove that `f = g`, maybe try to prove\n"
"instead that `f - g = 0`, so you can try proving the assumptions in `hS` with the function `f - g`. You\n"
"also need to pick the correct set to be summing over. Since this set must contain both `s` and `t`, you\n"
"can use `s ‚à™ t`. Also, note that this will then only prove that `f = g` on the set `s ‚à™ t`, so you may\n"
"need to use `by_cases` to prove it outside `s ‚à™ t`.\n"
"\n"
"### Note on hints\n"
"With the use of `have` statements, you may have multiple goals at the same time. While this is not a\n"
"problem when writing the proof, the hint system may get confused. Starting to type where you\n"
"intend to write your next tactic will help clear up what goal you are working on, so it will help the hint\n"
"system. However, in general, try to follow your intuition without blindly following the hints."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "## Summary\n"
"The `by_cases` tactic is able to create a new hypothesis, and split the goal into two cases: one where\n"
"the hypothesis is true, and one where the hypothesis is false.\n"
"\n"
"In general, if you write `by_cases h : P`, you will create one goal with a hypothesis `h : P`, and another\n"
"with a hypothesis `h : ¬¨P`.\n"
"\n"
"## Example\n"
"If you have some vector `v : V`, and some set `s : Set V`, you can solve the proof by cases of whether\n"
"v is in s by writing `by_cases h : v ‚àà s`, which will give you two goals, one with the hypothesis `h : v ‚àà s`,\n"
"and one with the hypothesis `h : v ‚àâ s`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "## Summary\n"
"The `funext` tactic is very helpful when dealing with functions. It uses the idea that for two functions\n"
"`f : A ‚Üí B` and `g : A ‚Üí B`, `f = g` if and only if `f x = g x` for all `x ‚àà A`. This means that if you\n"
"have a goal `f = g`, where both functions have domain `A`, `funext x` will create an arbitrary `x : A`,\n"
"and change the goal to `f x = g x`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "## Summary\n"
"The `specialize` tactic can be thought of as the opposite of `use`. While `use` helps specify a value\n"
"for a `‚àÉ` in the goal, `specialize` specifies a value for a `‚àÄ` in a hypothesis. If you have a hypothesis\n"
"`h`, `specialize h x1 x2 x3` will specify the values in `h` as `x1`, `x2`, and `x3`.\n"
"\n"
"## Example\n"
"If you have a hypothesis `h : ‚àÄ x : V, f x = 0`, and some `v : V`, then `specialize h v` will\n"
"change the hypothesis to `h : f v = 0`\n"
"\n"
"## Example\n"
"If you have a hypothesis `h : x ‚àà s ‚Üí f x = 0`, and another hypothesis `h2 : x ‚àà s`, then `specialize h h2`\n"
"will change h to `h : f x = 0`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "`coe_union` is a proof that `‚Üë(a ‚à™ b) = ‚Üëa ‚à™ ‚Üëb`. The `‚Üë` means type casting, which in this case\n"
"specifically means that if `a` is a `Finset`, then `‚Üëa` is a `Set` containing the same elements. This\n"
"theorem shows that type casting passes through unions."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "`union_subset` is a proof that if `a ‚äÜ c` and `b ‚äÜ c`, then `a ‚à™ b ‚äÜ c`. This means that if you\n"
"have two sets that are subsets of the same set, their union is also a subset of that set."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "`sum_add_distrib` is a proof that you can distribute addition over sums. This means that if\n"
"you have functions `f : A ‚Üí B`, and `g : A ‚Üí B`, and some set `s : Finset A`, then\n"
"`Finset.sum s (fun x => f x + g x) = Finset.sum s (fun x => f x) + Finset.sum s (fun x => g x)."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "`sum_sub_distrib` is a proof that you can distribute subtraction over sums. This means that if\n"
"you have functions `f : A ‚Üí B`, and `g : A ‚Üí B`, and some set `s : Finset A`, then\n"
"`Finset.sum s (fun x => f x - g x) = Finset.sum s (fun x => f x) - Finset.sum s (fun x => g x)."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "`Finset.subset_union_left` is a proof that if `a b : Finset S` are sets, then `a ‚äÜ a ‚à™ b`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "`Finset.subset_union_right` is a proof that if `a b : Finset S` are sets, then `b ‚äÜ a ‚à™ b`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "`sum_subset` is a proof that if you have a function that is zero outside of some set, then a sum\n"
"on a superset of that set is equal to a sum on that set. If you have a hypothesis `hSub : a ‚äÜ b`, another hypothesis\n"
"`hZero : ‚àÄ x ‚àà b, x ‚àâ a ‚Üí f x = 0`, then `sum_subset hSub hZero` is a proof that\n"
"`Finset.sum b f = Finset.sum a f`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "`sub_smul` is a proof that subtraction distributes over scalar multiplication. `sub_smul a b c` is a proof\n"
"that `(a - b) ‚Ä¢ c = a ‚Ä¢ c - b ‚Ä¢ c`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "`sub_eq_zero` is a proof that `a - b = 0` if and only if `a = b`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "`not_mem_union` is the contrapositive of the definition of a union of sets. It states that if\n"
"`v ‚àâ a ‚à™ b`, then `v ‚àâ a ‚àß v ‚àâ b`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "`linear_combination_unique` is a proof that representation as a linear combination of a linearly independent\n"
"set of vectors is unique. It takes in two subsets of a linearly independent set, along with two functions\n"
"representing the linear combinations. The functions must be zero outside of the sets, and their sums\n"
"must be equal. In this case, this prooves that functions will be equal."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "First, note that you have a goal of proving two functions equal. Try to instead prove it for\n"
"an arbitrary value."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `funext x`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Now, we can split into cases where either x ‚àà (s ‚à™ t) or not."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `by_cases h : x ‚àà (s ‚à™ t)`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `unfold linear_independent_v at hS`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Think about the forwards proof. What set and function are we summing over when applying the linear independence of S?"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `specialize hS (s ‚à™ t) (f - g)`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "We now want to show `‚Üë(s ‚à™ t) ‚äÜ S`. This is a type casted union. Instead, we want a union of\n"
"type casts, so that we can use theorems having to do with unions. One of the theorems should help with this"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `rw[coe_union] at hS`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `specialize hS (union_subset hs ht)`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Now, we have to show that `(Finset.sum (s ‚à™ t) fun v => (f - g) v ‚Ä¢ v) = 0`. This will\n"
"be difficult, so try proving it with a `have` statement. Remember to add braces after `by`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `have lemmaSumDiffEqZero : (Finset.sum (s ‚à™ t) fun v => (f - g) v ‚Ä¢ v) = 0 := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "It would be nice if we could distribute the `f - g` through the `‚Ä¢` operator. Try proving\n"
"`(fun v => (f - g) v ‚Ä¢ v) = (fun (v : V) => ((f v) ‚Ä¢ v) - ((g v) ‚Ä¢ v))` with another `have` statement. Remember to add braces after `by`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `  have fun_dist : (fun v => (f - g) v ‚Ä¢ v) = (fun (v : V) => ((f v) ‚Ä¢ v) - ((g v) ‚Ä¢ v)) := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `    funext v`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `    exact sub_smul (f v) (g v) v`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `  rw[fun_dist]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Now, we can split the sum in two"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `  rw[sum_sub_distrib]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "We now have two sums. The first one should be equivalent to our first linear combination,\n"
"and the second should be equivalent to our second linear combination. We need to change the sets\n"
"they are being summed over. We have a theorem that can do this, but it needs a hypothesis that we\n"
"don't have. Try proving these hypotheses with a `have` statement. Remember to add braces after `by`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `  have hfprod0 : ‚àÄ v ‚àà s ‚à™ t,  v ‚àâ s ‚Üí f v ‚Ä¢ v = 0 := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `intros v _hv1 hv2; rw[hf0 v hv2]; exact zero_smul_v K V v`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `have hgprod0 : ‚àÄ v ‚àà s ‚à™ t,  v ‚àâ t ‚Üí g v ‚Ä¢ v = 0 := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `intros v _hv1 hv2; rw[hg0 v hv2]; exact zero_smul_v K V v`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `  rw [(sum_subset (f := fun v => f v ‚Ä¢ v) (subset_union_left s t) hfprod0).symm]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `  rw [(sum_subset (f := fun v => g v ‚Ä¢ v) (subset_union_right s t) hgprod0).symm]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Now, we use the fact that the two sums are equal to finish the proof of the lemma"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `rw[heq]; simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Now, we simply have to prove the requirements of hS"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `specialize hS lemmaSumDiffEqZero`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `specialize hS x h`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "We know now from hS that f x - g x = 0, and one of the new theorems lets us finish the proof.\n"
"Remember that if you have a proof of `‚Üî`, `.1` will be a proof of the forwards direction and `.2` the\n"
"backwards."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `exact sub_eq_zero.1 hS`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `rw[not_mem_union] at h`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `cases' h with hxs hxt`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Note: The game may appear to stall after the next step. If it does, you can proceed to the next level - the proof is complete."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `rw[hf0 x hxs, hg0 x hxt]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Congratulations! The next two levels are optional challenges, and although they are\n"
"difficult, if you were able to complete this level, you should be able to complete the next two."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Challenge Level - Linear Independence of Set with Insertion"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "This is your first challenge level! It is meant to be an optional challenge for those\n"
"who want to have more practice proving difficult theorems in Lean.\n"
"\n"
"### The Goal\n"
"The goal of this level is to prove that if you have some linearly independent set of vectors `S`, and\n"
"some vector `v ‚àâ span S`, then the set `S ‚à™ {v}` is also linearly independent.\n"
"\n"
"### How to skip the level\n"
"In this level, you will have access to the `sorry` tactic. This tactic is how you tell Lean \"I couldn't\n"
"finish the proof, but pretend like I did.\" Typing this tactic will always solve the goal, and allow\n"
"you to skip the level\n"
"\n"
"### Proof overview\n"
"Linear independence means that any linear combination that adds to zero must be all zeros. This means\n"
"that in order to show `S ‚à™ {v}` is linearly independent, you must introduce an arbitrary linear combination\n"
"with the function `f` over a set `s`. Here, you can consider whether `v ‚àà s` or not. If not, the proof\n"
"is simple, since `s` is a subset of `S` we already know `S` is linearly independent. If it is, we need\n"
"to prove `f(v) = 0`. This can be done since `v ‚àâ span S`, along with some clever choice of functions.\n"
"Once you have `f(v) = 0`, you can show that the function must be zero outside of `v` due to the linear\n"
"independence of `S`, which then shows `f` is zero on `s`.\n"
"\n"
"### New tactics/theorems\n"
"Similarly to the last level, there are new tactics and theorems you can read about to the right side.\n"
"Also, something that may be useful is the `‚Åª¬π` function. `x‚Åª¬π` is the multiplicative inverse of `x`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "`sorry` allows you to skip levels. The `sorry` tactic will solve any goal, and although it is not actually\n"
"a proof, Lean treats it as one."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "## Summary\n"
"`by_contra` allows you to prove theorems by contradiction. When your goal is `P`, `by_contra h` will\n"
"create a hypothesis `h : ¬¨P` and change the goal to `False`.\n"
"\n"
"## Example\n"
"If your goal is `¬¨(isRational ‚àö2)`, using `by_contra h` will change the goal to `False`, and\n"
"give you a hypothesis `h : isRational ‚àö2`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "If you have some set s, where you know `h : i ‚àà s`, then `sum_eq_sum_diff_singleton_add h` is a proof that\n"
"`(Finset.sum s fun x => f x) = (Finset.sum (s \\ {i}) fun x => f x) + f i`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "`smul_sum` is a proof that you can distribute scalar multiplication through `Finset.sum`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "`inv_mul_cancel` is a proof that multiplying a nonzero inverse gives 1. If you have a hypothesis `h : x ‚â† 0`,\n"
"then  `inv_mul_cancel h` is a proof that `x‚Åª¬π * x = 1`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "`linear_independent_insert_of_not_in_span` is a proof that if you have a linearly independent set, and\n"
"you insert an element not in the span of that set, the new set is also linearly independent. The syntax\n"
"is as follows: if you have hypotheses `hS : linear_independent_v K V S`, and `hv_not_span : v ‚àâ span K V S`,\n"
"then `linear_independent_insert_of_not_in_span hS hv_not_span` is a proof of `linear_independent_v K V (S ‚à™ {v})`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "First, unfold the definitions, intro the variables and hypotheses we need, and simp where nescessary"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `unfold linear_independent_v at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `intros s f hs hf w hw`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `unfold span at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `unfold is_linear_combination at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp at hv_not_span`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "We want to prove two seperate cases: v ‚àà s and v ‚àâ s. If v ‚àâ s, then we know s ‚äÜ S, so since S\n"
"is linearly independent, so is s. If v ‚àà s, then we have more work to do."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `by_cases hvIns : v ‚àà ¬´{s}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Now, we want to split ¬´{hf}¬ª into two, breaking off ¬´{v}¬ª so we have a sum over a subset of ¬´{S}¬ª"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw [sum_eq_sum_diff_singleton_add ¬´{hvIns}¬ª] at ¬´{hf}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Now, that we have a sum over `(s \\ {v})`, we want to show `‚Üë(s \\ {v}) ‚äÜ S`. Remember to add braces after `by`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `have subset : ‚Üë(¬´{s}¬ª \\ {v}) ‚äÜ S := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `intros x hx`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp at ¬´{hx}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `cases' ¬´{hx}¬ª with xs xNev`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `have xInUnion := ¬´{hs}¬ª ¬´{xs}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp at ¬´{xInUnion}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `cases' ¬´{xInUnion}¬ª with xEqv xInS`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exfalso`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exact ¬´{xNev}¬ª ¬´{xEqv}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exact ¬´{xInS}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Now, we can prove our important lemma, that `¬´{f}¬ª v = 0`. Remember to add braces after `by`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `have lemma_fv_zero : ¬´{f}¬ª v = 0 := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "A good way to prove this is by contradiction"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `by_contra hfv_ne_zero`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "In order to use ¬´{hv_not_span}¬ª, we need to show ¬´{v}¬ª as a linear combination of a subset of ¬´{S}¬ª.\n"
"This can be done with a `have` statement. Remember to add braces after `by`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `have hvLinearCombo : v = (¬´{s}¬ª \\ {v}).sum (fun x => (-(¬´{f}¬ª v)‚Åª¬π * (¬´{f}¬ª x)) ‚Ä¢ x) := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Not that the `simp only [theorem]` tactic allows us to rewrite using theorems inside a function, which cannot be done with just rw"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp only [mul_smul]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Now, use some of the theorems we have to simplify the goal to an equality"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw[(smul_sum (r := -(¬´{f}¬ª v)‚Åª¬π) (f := fun x => ¬´{f}¬ª x ‚Ä¢ x) (s := (¬´{s}¬ª \\ {v}))).symm]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw [(neg_add_self ((¬´{f}¬ª v) ‚Ä¢ v)).symm] at ¬´{hf}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw[add_right_cancel ¬´{hf}¬ª]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw[(mul_smul (¬´{f}¬ª v)‚Åª¬π (¬´{f}¬ª v) v).symm]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw[inv_mul_cancel ¬´{hfv_ne_zero}¬ª, one_smul]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Now, we can use ¬´{hv_not_span}¬ª to find our contradiction"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `specialize ¬´{hv_not_span}¬ª (¬´{s}¬ª \\ {v})`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `specialize ¬´{hv_not_span}¬ª ¬´{subset}¬ª (fun x => -(¬´{f}¬ª v)‚Åª¬π * (¬´{f}¬ª x))`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exact ¬´{hv_not_span}¬ª ¬´{hvLinearCombo}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Now, consider two cases: `¬´{w}¬ª = ¬´{v}¬ª` or not. If `¬´{w}¬ª = ¬´{v}¬ª`, our lemma is our goal. If not,\n"
"we need to use the linear independence of `S`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `by_cases hw2 : ¬´{w}¬ª = v`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw [¬´{hw2}¬ª]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exact ¬´{lemma_fv_zero}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "We can use our lemma to show that the sum of `¬´{f}¬ª` over `¬´{s}¬ª \\ {¬´{v}¬ª}` is equal to 0"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw[¬´{lemma_fv_zero}¬ª] at ¬´{hf}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp at ¬´{hf}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "We want to show that `¬´{w}¬ª ‚àà ¬´{s}¬ª \\ {¬´{v}¬ª}`. Remember to add braces after `by`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `have hwInS : ¬´{w}¬ª ‚àà ¬´{s}¬ª \\ {v} := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exact hw`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exact hw2`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Now, we can apply all of our hypotheses to close the goal"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exact ¬´{hS}¬ª (¬´{s}¬ª \\ {v}) ¬´{f}¬ª ¬´{subset}¬ª ¬´{hf}¬ª ¬´{w}¬ª ¬´{hwInS}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "We now need to show that s ‚äÜ S, and we can use the linear independence of S to show s is linearly independent. Remember to add braces after `by`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `have s_subset_S : ‚Üë¬´{s}¬ª ‚äÜ S := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `intro u hu_in_s`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `cases' ¬´{hs}¬ª ¬´{hu_in_s}¬ª with hu_in_S hu_eq_v`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exact ¬´{hu_in_S}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp at ¬´{hu_eq_v}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw [¬´{hu_eq_v}¬ª] at ¬´{hu_in_s}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exfalso`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exact ¬´{hvIns}¬ª ¬´{hu_in_s}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Now, we can use the linear independence of S to finish the proof"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Note: The game may appear to stall after the next step. If it does, you can proceed to the next level - the proof is complete."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exact ¬´{hS}¬ª ¬´{s}¬ª ¬´{f}¬ª ¬´{s_subset_S}¬ª ¬´{hf}¬ª ¬´{w}¬ª ¬´{hw}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Challenge Level - Span After Removing Elements"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "This is the second challenge level, and the last level of the Linear Independence and Span World! Similar\n"
"to the first challenge level, this level is optional and can be skipped with the `sorry` tactic, but you can\n"
"play through it if you want more practice.\n"
"\n"
"### The Goal\n"
"The goal of this level is to prove that if you have some set `S`, and some vector `w` inside the span\n"
"of `S \\ {w}`, the span of `S` is the same as the span of `S \\ {w}`. This is because `w` can be written\n"
"as a sum of vectors of `S \\ {w}`, so any time you have `w` appear in a linear combination of `S`, you\n"
"can simply replace it with a sum of vectors in `S \\ {w}`.\n"
"\n"
"### Proof overview\n"
"The most difficult part of this proof is showing that given a linear representation of a vector in the\n"
"span of `S`, we can represent it as a sum of vectors in `S \\ {w}`. You are able to represent a sum over\n"
"`S` as a sum over `S \\ {w}` plus the function applied to `w`. Then, rewrite `w` as a sum of vectors\n"
"in `S \\ {w}`, and recombine the sums."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "`subset_insert` is a proof that any set is a subset of itself with an element inserted. In Lean, the\n"
"syntax is as follows: if `s : Set T` is a set, and you have `x : T`, then `s ‚äÜ Set.insert x s`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "`Finset.Subset.antisymm_iff` is a proof that two Finsets are equal if and only if they are subsets of each other."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "`sum_eq_sum_diff_singleton_add` is a proof that if you have some set `s`, with `h : i ‚àà s`, then\n"
"`Finset.sum s (fun x => f x) = Finset.sum (s / {i}) (fun x => f x) + f i. The syntax is `sum_eq_sum_diff_singleton_add h f`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "`mem_union_right` is a proof that if `a ‚àà t`, then `a ‚àà s ‚à™ t`. The syntax is `mem_union_right s h`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "`subset_diff_singleton` is a proof that if `h : s ‚äÜ t`, and `hx : x ‚àâ s`, then `s ‚äÜ t \\ {x}`. The syntax\n"
"is `subset_diff_singleton h hx`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "`diff_subset` is a proof that `s ‚äÜ s \\ t`. The syntax is `diff_subset s t`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "## Summary\n"
"`tauto` solves goals using simple logic. It works similarly to the `simp` and `linarith` tactics, in\n"
"that there is not just one use case. If there is a contradiction that can be easily inferred, or if\n"
"the goal is a direct result of the hypotheses, `tauto` will solve the goal.\n"
"\n"
"## Example\n"
"If your goal is of the form `P ‚à® ¬¨P`, then `tauto will solve the goal.\n"
"\n"
"## Example\n"
"If your goal is of the form `A ‚à® B`, and you have a hypothesis `h : A ‚à® (B ‚àß C)`, then `tauto` will\n"
"solve the goal."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "## Summary\n"
"`left` is one of the ways of proving `or` statements. If your goal is `P ‚à® Q`, then `left` changes the\n"
"goal to `P`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "## Summary\n"
"`right` is one of the ways of proving `or` statements. If your goal is `P ‚à® Q`, then `right` changes the\n"
"goal to `Q`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "## Summary\n"
"`let` acts very similarly to `have`. Instead of allowing you to create new hypotheses, `let` allows you\n"
"to create new objects.\n"
"\n"
"## Using `rw` after `let` statements\n"
"You may want to use `rw` with the equalities you choose in a `let` statement. To do this, you must create\n"
"a new lemma stating this equality with `have`. The proof will simply be `rfl`.\n"
"\n"
"## Example\n"
"If you have objects `x y : V`, then you can say `let z := x + y`, and you will have a new object `z`,\n"
"where `z = x + y` can be solvedd by `rfl`\n"
"\n"
"## Example\n"
"If you have a function `f : V ‚Üí K`, and `v : V`, you can say `let f := fun x => f x ‚Ä¢ v`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "`ite` stands for `if then else`. If is used when creating functions. You can think of `ite P f1 f2` as\n"
"\"If P then f1 else f2\". This function gives you f1 when P is True, and f2 otherwise. This can help you\n"
"design functions that are 0 outside of certain sets."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid ""
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "We want to prove two sets are equal. What theorem can help us with this?"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `apply Set.eq_of_subset_of_subset`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "First, introduce an arbitrary element, unfold definitions and simp"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `intro x hx`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `unfold span at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `unfold is_linear_combination at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `simp at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Now, we have two helpful statements. We can use `obtain` to get sets and functions from them"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `obtain ‚ü®sw, hsw, fw, hfw‚ü© := hcomb`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `obtain ‚ü®sx, hsx, fx, hfx‚ü© := hx`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Here, we can split into two cases: whether or not `w ‚àà sx`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `by_cases hw : w ‚àà sx`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "What set should we be summing over? Note that you have two different sets where functions are\n"
"defined, ¬´{sw}¬ª and ¬´{sx}¬ª"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `use ¬´{sw}¬ª ‚à™ (¬´{sx}¬ª \\ {w})`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `rw[coe_union]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `apply Set.union_subset ¬´{hsw}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `exact subset_trans ¬´{hsx}¬ª (subset_insert w S)`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "In order to manipulate the sum better, it would be nice to rewrite the set you are summing over.\n"
"You can use a `have` statement to show that this set is equal to `(¬´{sw}¬ª ‚à™ ¬´{sw}¬ª \\ {w})`. Remember to add braces after `by`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `have set_eq : ¬´{sw}¬ª ‚à™ (¬´{sx}¬ª \\ {w}) = (¬´{sw}¬ª ‚à™ ¬´{sx}¬ª) \\ {w} := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `apply Finset.Subset.antisymm_iff.2`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `intro x hx`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `simp at ¬´{hx}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `tauto`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `cases' ¬´{hx}¬ª with hInsw hInsx`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `intro hEqW`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `rw[¬´{hEqW}¬ª] at ¬´{hInsw}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `have hContra := ¬´{hsw}¬ª ¬´{hInsw}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try simp at ¬´{hContra}¬ª``"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `exact ¬´{hInsx}¬ª.2`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `intro x hx`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `simp at ¬´{hx}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `cases' ¬´{hx}¬ª with hl hr`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `cases' ¬´{hl}¬ª with hInsw hInsx`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `left`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `exact ¬´{hInsw}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `right`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `exact ¬´{hInsx}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `exacr ¬´{hr}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Now, let's consider the function we will be summing. To get a sum of `¬´{x}¬ª`, we need two parts:\n"
"the sum over `S` getting `¬´{x}¬ª`, and the sum over `S \\ {w}` to get `w`. This can be thought of as\n"
"two seperate functions. The first function will be similar to `¬´{fx}¬ª`, but since we do not know what\n"
"`¬´{fx}¬ª` is outside of `¬´{sx}¬ª`, we must make this function `0` outside of `sx`. We can define this first\n"
"function with a `let` statement"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `let fx' := fun v => (ite (v ‚àà ¬´{sx}¬ª) (¬´{fx}¬ª v) 0)`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `have hfx' : ¬´{fx'}¬ª = (fun v => (ite (v ‚àà ¬´{sx}¬ª) (¬´{fx}¬ª v) 0)) := rfl`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Now, you can prove that summing `¬´{fx'}¬ª` over our set gives the correct value. Prove this with\n"
"a `have` statement. Remember to add braces after `by`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `have fx'_sum : ¬´{x}¬ª - (¬´{fx}¬ª w ‚Ä¢ w) = (¬´{sw}¬ª ‚à™ (¬´{sx}¬ª \\ {w})).sum (fun v => ¬´{fx'}¬ª v ‚Ä¢ v) := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `rw[set_eq]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `apply add_right_cancel (b := ¬´{fx}¬ª w ‚Ä¢ w)`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `have hfx'w : ¬´{fx}¬ª w = ¬´{fx'}¬ª w := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `rw[¬´{hfx'}¬ª]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `simp only [¬´{hw}¬ª]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `rw[¬´{hfx'w}¬ª]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `rw[(sum_eq_sum_diff_singleton_add (mem_union_right ¬´{sw}¬ª ¬´{hw}¬ª) (fun v => ¬´{fx'}¬ª v ‚Ä¢ v)).symm]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `rw[¬´{hfx'}¬ª]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `exact ¬´{hfx}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Now, we can create the second function, which will be added to get the missing `¬´{fx}¬ª w ‚Ä¢ w`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `let fw' := fun v => ite (v ‚àà ¬´{sw}¬ª) (¬´{fx}¬ª w * ¬´{fw}¬ª v) 0`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `have hfw' : ¬´{fw'}¬ª = (fun v => ite (v ‚àà ¬´{sw}¬ª) (¬´{fx}¬ª w * ¬´{fw}¬ª v) 0) := rfl`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Again, prove that the function sums to the correct value. Remember to add braces after `by`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `have fw'_sum : ¬´{fx}¬ª w ‚Ä¢ w = (¬´{sw}¬ª ‚à™ (¬´{sx}¬ª \\ {w})).sum (fun v => ¬´{fw'}¬ª v ‚Ä¢ v) := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `rw[¬´{hfw'}¬ª]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `simp only [mul_smul]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `rw[(smul_sum (r := ¬´{fx}¬ª w) (s := ¬´{sw}¬ª) (f := fun v => ¬´{fw}¬ª v ‚Ä¢ v)).symm]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `rw[¬´{hfw}¬ª]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Now, use the functions we have defined"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `use fun v => ¬´{fx'}¬ª v + ¬´{fw'}¬ª v`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `simp only [add_smul]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `rw[sum_add_distrib, ¬´{fx'_sum}¬ª.symm, ¬´{fw'_sum}¬ª.symm]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Now, we are on the second case, when `w ‚àâ ¬´{sx}¬ª."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `use ¬´{sx}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `exact subset_diff_singleton ¬´{hsx}¬ª ¬´{hw}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `use fx`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Lastly, we must prove that `span K V (S \\ {w}) ‚äÜ span K V S`. This is simple with span_mono"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `apply span_mono`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "Try `exact diff_subset S {w}`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level10
msgid "You have now finished the Linear Independence and Span World!"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld
msgid "Linear Independence and Span World"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld
msgid "Welcome to Linear Independence and Span World! \n"
"\n"
"This world introduces the ideas of linear independence, linear dependence, and the span of a set of vectors. \n"
"\n"
"You will prove theorems, for example that any subset of a linearly independent set of vectors is still linearly independent.\n"
"\n"
"**Note:** If this introduction page appears blank or incomplete, please click 'Start' and go directly to Level 1, which contains a detailed introduction to linear combinations and the concepts in this world.\n"
"\n"
"Click start to begin your first level!"
msgstr ""

#: Game.Levels.InnerProductWorld.Level01
msgid "Norm Is Nonnegative"
msgstr ""

#: Game.Levels.InnerProductWorld.Level01
msgid "The first level of this world will introduce two new ideas, the inner product and the norm.\n"
"The inner product is a way of taking two vectors, and multiplying them to get a complex number. There\n"
"are five main axioms that make such a function a valid inner product. First, any vector's inner product\n"
"with itself must be a nonnegative real number. Secondly, a vector's inner product with itself must\n"
"equal zero if and only if the vector is itself 0. The third and fourth axioms are that you can distribute\n"
"vector addition and commute vector multiplication through the first element of the product. Lastly, the\n"
"inner product has conjugate symmetry, that is that `‚ü™u, v‚ü´ = conj ‚ü™v, u‚ü´. Also, note that in any inner\n"
"product space, our field K must be a subfield of ‚ÑÇ. For convenience we will assume K is equal to ‚ÑÇ.\n"
"This is what allows us to commute multiplication through the inner product.\n"
"\n"
"```\n"
"-- Inner product space definition for complex vector spaces\n"
"class InnerProductSpace_v (V : Type) [AddCommGroup V] [VectorSpace ‚ÑÇ V] where\n"
"  inner : V ‚Üí V ‚Üí ‚ÑÇ\n"
"  inner_self_im_zero : ‚àÄ (v : V), (inner v v).im = 0\n"
"  inner_self_nonneg : ‚àÄ (v : V), 0 ‚â§ (inner v v).re\n"
"  inner_self_eq_zero : ‚àÄ (v : V), inner v v = 0 ‚Üî v = 0\n"
"  inner_add_left : ‚àÄ (u v w : V), inner (u + v) w = inner u w + inner v w\n"
"  inner_smul_left : ‚àÄ (a : ‚ÑÇ) (v w : V), inner (a ‚Ä¢ v) w = a * inner v w\n"
"  inner_conj_symm : ‚àÄ (v w : V), inner v w = conj (inner w v)\n"
"```\n"
"\n"
"Once we have the inner product, vector norms are easy to define. We simply let `‚Äñv‚Äñ = sqrt ‚ü™v, v‚ü´.re`,\n"
"which means that the norm of `v` is the square root of it's inner product with itself (we take `.re`)\n"
"to make sure that `‚ü™v, v‚ü´` is a real number, although we already guarantee this with the first axiom).\n"
"Note that the norm is called `norm_v`, which is what you should use if you try to `unfold`.\n"
"\n"
"```\n"
"def norm_v (v : V) : ‚Ñù := Real.sqrt ‚ü™v, v‚ü´.re\n"
"```\n"
"\n"
"## The Goal\n"
"This first level requires you to prove that `0 ‚â§ ‚Äñv‚Äñ`. Since norm is defined as the square root of a\n"
"nonnegative real number, it is inherenetly positive."
msgstr ""

#: Game.Levels.InnerProductWorld.Level01
msgid "The square root of any real number is nonnegative"
msgstr ""

#: Game.Levels.InnerProductWorld.Level01
msgid "For any vector `v`, the imaginary part of `‚ü™v, v‚ü´` is zero. Equivalently, `‚ü™v, v‚ü´` is real."
msgstr ""

#: Game.Levels.InnerProductWorld.Level01
msgid "For any vector `v` the real part of `‚ü™v, v‚ü´` is nonnegative."
msgstr ""

#: Game.Levels.InnerProductWorld.Level01
msgid "For any vector `v`, `‚ü™v, v‚ü´ = 0` if and only if `v` is the zero vector"
msgstr ""

#: Game.Levels.InnerProductWorld.Level01
msgid "For any vectors `u, v, w`, ‚ü™(u + v), w‚ü´ = ‚ü™u, w‚ü´ + ‚ü™v, w‚ü´. That is, inner products distribute over addition"
msgstr ""

#: Game.Levels.InnerProductWorld.Level01
msgid "For any vectors `v, w`, and a scalar `a`, ‚ü™a ‚Ä¢ v, w‚ü´ = a * ‚ü™v, w‚ü´. This means that scalar multiplication\n"
"commutes with the inner product."
msgstr ""

#: Game.Levels.InnerProductWorld.Level01
msgid "For any vectors `v, w`, `‚ü™v, w‚ü´ = conj ‚ü™w, v‚ü´`. This means that the inner product commutes if you take\n"
"the conjugate."
msgstr ""

#: Game.Levels.InnerProductWorld.Level01
msgid "`InnerProductSpace_v` is how we define inner products. An `InnerProductSpace_v` is another class, similar\n"
"to how a `VectorSpace` is a class, and it defines a function `inner` that takes two elements of `V`\n"
"and gives an element of `‚ÑÇ`. `inner` can also be written as `‚ü™v, w‚ü´`. An InnerProductSpace must be a\n"
"vector space with field `K = ‚ÑÇ`, and the inner product must satisfy five axioms: First, any vector's inner product\n"
"with itself must be a nonnegative real number. Secondly, a vector's inner product with itself must\n"
"equal zero if and only if the vector is itself 0. The third and fourth axioms are that you can distribute\n"
"vector addition and commute vector multiplication through the first element of the product. Lastly, the\n"
"inner product has conjugate symmetry, that is that `‚ü™u, v‚ü´ = conj ‚ü™v, u‚ü´. The Lean code defining this is\n"
"\n"
"```\n"
"class InnerProductSpace_v (V : Type) [AddCommGroup V] [VectorSpace ‚ÑÇ V] where\n"
"  inner : V ‚Üí V ‚Üí ‚ÑÇ\n"
"\n"
"  -- 1. Positivity: ‚ü®v,v‚ü© is real and non-negative\n"
"  inner_self_im_zero : ‚àÄ (v : V), (inner v v).im = 0\n"
"  inner_self_nonneg : ‚àÄ (v : V), 0 ‚â§ (inner v v).re\n"
"\n"
"  -- 2. Definiteness: ‚ü®v,v‚ü© = 0 iff v = 0\n"
"  inner_self_eq_zero : ‚àÄ (v : V), inner v v = 0 ‚Üî v = 0\n"
"\n"
"  -- 3. Additivity in first slot: ‚ü®u + v, w‚ü© = ‚ü®u, w‚ü© + ‚ü®v, w‚ü©\n"
"  inner_add_left : ‚àÄ (u v w : V), inner (u + v) w = inner u w + inner v w\n"
"\n"
"  -- 4. Homogeneity in first slot: ‚ü®a ‚Ä¢ v, w‚ü© = a * ‚ü®v, w‚ü©\n"
"  inner_smul_left : ‚àÄ (a : ‚ÑÇ) (v w : V), inner (a ‚Ä¢ v) w = a * inner v w\n"
"\n"
"  -- 5. Conjugate symmetry: ‚ü®v, w‚ü© = conj(‚ü®w, v‚ü©)\n"
"  inner_conj_symm : ‚àÄ (v w : V), inner v w = conj (inner w v)\n"
"```"
msgstr ""

#: Game.Levels.InnerProductWorld.Level01
msgid "`norm_v` is how we define vector norms. It can also be written as `‚Äñv‚Äñ`. We define the norm of a vector\n"
"`v` as the square root of it's inner product with itself. The lean code defining this is\n"
"\n"
"```\n"
"def norm_v (v : V) : ‚Ñù := Real.sqrt ‚ü™v, v‚ü´.re\n"
"```"
msgstr ""

#: Game.Levels.InnerProductWorld.Level01
msgid "The norm of any vector is non-negative."
msgstr ""

#: Game.Levels.InnerProductWorld.Level01
msgid "Try unfolding the new definition"
msgstr ""

#: Game.Levels.InnerProductWorld.Level01
msgid "Try `unfold norm_v`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level01
msgid "Try `exact Real.sqrt_nonneg ‚ü™v,v‚ü´.re`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Zero Norm if and only if Zero Vector"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "## The Goal\n"
"In this level, we prove that the norm of a vector is zero if and only if it is the zero vector. The\n"
"idea of the proof is to use the `inner_self_eq_zero` axiom, which requires cancelling out the square\n"
"roots.\n"
"\n"
"## The `apply_fun` tactic\n"
"The `apply_fun` tactic is used to apply functions to both sides of an equality. This only works in your\n"
"hypotheses, not in the goal. The syntax is `apply_fun (fun x => f x) at h`. If `h : a = b` is a proof,\n"
"then this will change `h` to `h : f a = f b`. This tactic can be very helpful, as squaring a square root\n"
"cancels out the operation."
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "## Summary\n"
"`apply_fun` allows you to apply functions to both sides of an equality in the hypothesis. This can also\n"
"be done simply with a `have`, `rw`, and `rfl` statement, but it is nice to be able to do that in one line.\n"
"\n"
"## Example\n"
"If you have `h : sqrt x = 0`, using `apply_fun (fun v => v ^ 2) at h` will change `h` to `h : (sqrt x) ^ 2 = 0 ^ 2`."
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "`sq_sqrt` is a proof that if `0 ‚â§ x`, then `(sqrt x) ^ 2 = x`. It allows you to cancel out square roots."
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "`Complex.ext` allows you to split complex numbers into their real and imaginary parts. If your goal is\n"
"of the form `a = b`, where `(a b : ‚ÑÇ)`, then `apply Complex.ext` will create two goals, one `a.re = b.re`,\n"
"and the other `a.im = b.im`."
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "`norm_zero_v` is a proof that `‚Äñv‚Äñ = 0 ‚Üî v = 0`, or that the only vector with norm zero is the zero vector."
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Try unfolding and using constructor to split the `‚Üî`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Try `unfold norm_v`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Try `intro h`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Now, try to remove the square root"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Try `apply_fun (fun x => x^2) at ¬´{h}¬ª`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Try `rw[sq_sqrt (inner_self_nonneg v)] at ¬´{h}¬ª`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Try `simp at h`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Now, try to use some of the theorems we know"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Try `apply (inner_self_eq_zero v).1`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Try `apply Complex.ext`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Try `exact ¬´{h}¬ª`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Try `exact inner_self_im_zero v`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Try `intro h`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Try `rw [¬´{h}¬ª]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Try `rw [(inner_self_eq_zero 0).2]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Try `simp`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level02
msgid "Try `rfl`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Norm of a Scaled Vector"
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "## The Goal\n"
"In this level, we show that you can take scalar multiples out from the norm of a vector, as long as\n"
"you multiply by the complex norm of the scalar. The proof here takes multiple steps. The first idea\n"
"is to square each side, getting rid of the square roots. Then, you can use multiple theorems to rewrite\n"
"the goal to be solved by an exact statement.\n"
"\n"
"## The `ring` tactic\n"
"`ring` again acts very similar to `linarith`, but it works for equations using rings. Rings are basically\n"
"objects where you can multiply and divide, for example, the complex numbers.\n"
"\n"
"## The `‚Üê` character\n"
"The `‚Üê` character acts similarly to `.symm`, but you often do not need to specify the exact details\n"
"of what you are rewriting, as you need to do with `.symm` The syntax looks like `‚Üê thm` instead of `thm.symm`\n"
"\n"
"## Note on `InnerProductSpace_v`\n"
"Some of the axioms and theorems you have share names with other theorems. If you run into a bug saying\n"
"\"Ambiguous, possible interpretations\", try specifying the exact name of your theorem by putting `InnerProductSpace_v.`\n"
"in front of the theorem name (e.g., `InnerProductSpace_v.inner_smul_left`)."
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "## Summary\n"
"`ring` acts very similar to `simp` and `linarith` in that it will attempt to solve the goal for you.\n"
"`ring` works best with rings, which are objects where you can add and multiply. The most common rings\n"
"you will see are the real and complex numbers.\n"
"\n"
"## Example\n"
"If you have a goal `(a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^2`, `ring` will solve the goal."
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "`norm_nonneg` is very similar to the vector space theorem `norm_nonneg_v`. The theorem shows that any\n"
"complex number has nonnegative norm."
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "`Left.mul_nonneg` is a proof that multiplying two nonnegative numbers will give a nonnegative value.\n"
"If you have hypotheses `h1 : 0 ‚â§ a`, `h2 : 0 ‚â§ b`, then `Left.mul_nonneg h1 h2` is a proof that `0 ‚â§ a * b`."
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "`sq_eq_sq` is a proof that if `a` and `b` are nonnegative, `a^2 = b^2` if and only if `a = b`. If you\n"
"have hypotheses `h1 : 0 ‚â§ a`, `h2 : 0 ‚â§ b`, then `sq_eq_sq h1 h2` is a proof that `a ^ 2 = b ^ 2 ‚Üî a = b`."
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "`mul_assoc` is a proof that multiplication is associative. That is, that if you have `a, b, c`, then\n"
"`a * (b * c) = (a * b) * c`."
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "`mul_conj` is a proof that `z * conj z = ‚Üë(normSq z)`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "`normSq_eq_norm_sq` is a proof that `normSq z = ‚Äñz‚Äñ ^ 2`. It essentially unfolds the `normSq` definition."
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "`re_ofReal_mul` is a proof that `(‚Üër * z).re = r * z.re`. It is helpful when working with both real and\n"
"complex numbers at the same time."
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "The norm of a scalar multiple: `‚Äña ‚Ä¢ v‚Äñ= ‚Äña‚Äñ * ‚Äñv‚Äñ`.\n"
"This fundamental property shows how norms interact with scalar multiplication."
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "The square of the norm equals the real part of the inner product with itself:\n"
"`‚Äñv‚Äñ ^ 2 = ‚ü™v, v‚ü´.re`. This connects the geometric notion of length with the algebraic inner product."
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "First, establish non-negativity of the norms to use the square equality theorem."
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Try `have h1 := norm_nonneg a`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Try `have h2 := norm_nonneg_v v`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Combine these to get non-negativity of the product."
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Try `have g1 := Left.mul_nonneg h1 h2`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Also get non-negativity of the left side."
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Try `have g2 := norm_nonneg_v (a ‚Ä¢ v)`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Now apply the square equality theorem to reduce to proving the squared version."
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Try `apply (sq_eq_sq g2 g1).1`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Use `ring_nf` to simplify the goal"
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Try `ring_nf`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Use our theorems to simplify the goal. Also, remember the `exact?`\n"
"tactic can help you find when to use `exact`."
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Try `repeat rw[norm_sq_eq]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Try `rw [InnerProductSpace_v.inner_smul_left]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Try `rw [inner_smul_right_v]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Try `rw[‚Üê mul_assoc]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Try `rw[mul_conj]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Try `rw[normSq_eq_norm_sq]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level03
msgid "Try `exact re_ofReal_mul (‚Äña‚Äñ ^ 2) ‚ü™v,v‚ü´`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level04
msgid "Orthogonality With Self"
msgstr ""

#: Game.Levels.InnerProductWorld.Level04
msgid "We now introduce orthogonality. Two vectors being orthogonal is equivalent to having their inner product\n"
"be 0. In Lean, we write this as\n"
"\n"
"```\n"
"def orthogonal (u v : V) : Prop := ‚ü™u, v‚ü´ = (0 : ‚ÑÇ)\n"
"```\n"
"\n"
"## The Goal\n"
"In this level, we show that the only vector that is orthogonal to itself is the zero vector.\n"
"This proof is very similar to our axiom `inner_self_eq_zero`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level04
msgid "`orthogonal` is how we say vectors are orthogonal. The syntax is `orthogonal v w`. This means that the\n"
"inner product of `v` and `w` is `0`. In Lean, we define it by saying\n"
"\n"
"```\n"
"def orthogonal (u v : V) : Prop := ‚ü™u, v‚ü´ = (0 : ‚ÑÇ)\n"
"```"
msgstr ""

#: Game.Levels.InnerProductWorld.Level04
msgid "`ortho_self_zero` is a proof that the only vector orthogonal to itself is the zero vector. If `v` is\n"
"a vector, `ortho_self_zero v` is a proof that `ortho v v ‚Üî v = 0`."
msgstr ""

#: Game.Levels.InnerProductWorld.Level04
msgid "Try unfolding orthogonal"
msgstr ""

#: Game.Levels.InnerProductWorld.Level04
msgid "Try `unfold orthogonal`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level04
msgid "Try `exact inner_self_eq_zero v`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level05
msgid "Pythagorean Theorem"
msgstr ""

#: Game.Levels.InnerProductWorld.Level05
msgid "## The Goal\n"
"This level has you prove the Pythagorean Theorem. In an abstract vector space, this theorem is a proof\n"
"that given any two orthogonal vectors, `u, v`, then `‚Äñu + v‚Äñ^2 = ‚Äñu‚Äñ^2 + ‚Äñv‚Äñ^2`. The idea behind the\n"
"proof is quite simple. Since all the norms are squared, we can remove the square roots, and then simplify\n"
"using the axioms of inner products."
msgstr ""

#: Game.Levels.InnerProductWorld.Level05
msgid "This is the Pythagorean Theorem. If you have vectors `u v`, and `h : orthogonal u v`, then\n"
"`pythagorean u v h` is a proof that `‚Äñu + v‚Äñ^2 = ‚Äñu‚Äñ^2 + ‚Äñv‚Äñ^2`."
msgstr ""

#: Game.Levels.InnerProductWorld.Level05
msgid "First, try to remove the squares."
msgstr ""

#: Game.Levels.InnerProductWorld.Level05
msgid "Try `repeat rw[norm_sq_eq]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level05
msgid "Now, try to expand `‚ü™u + v, u + v‚ü´` with our additivity properties."
msgstr ""

#: Game.Levels.InnerProductWorld.Level05
msgid "Try `rw[inner_add_left u v (u + v)]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level05
msgid "Try `rw [inner_add_right_v u u v]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level05
msgid "Try `rw [inner_add_right_v v u v]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level05
msgid "Keep simplifying!"
msgstr ""

#: Game.Levels.InnerProductWorld.Level05
msgid "Try `rw[inner_conj_symm v u]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level05
msgid "Try `unfold orthogonal at h`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level05
msgid "Try `rw[h]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level05
msgid "Try `simp`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "Orthogonal Decomposition"
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "One of the most important theorems in linear algebra is orthogonal decomposition. This allows you to\n"
"represent a vector as a scalar multiple of one vector, along with a vector orthogonal to that vector.\n"
"This includes the concepts of projections and othogonal components.\n"
"\n"
"## The Goal\n"
"In this level, we are given two vectors, `u` and `v`. `u` is the vector we want to rewrite, and `v`\n"
"is the vector we are scaling and getting the orthogonal component of. We also assume `h : v ‚â† 0`. From\n"
"this, we can calculate our sum as `u = (‚ü™u,v‚ü´ / (‚Äñv‚Äñ^2)) ‚Ä¢ v + (u - (‚ü™u,v‚ü´ / (‚Äñv‚Äñ^2)) ‚Ä¢ v))`. The equality\n"
"is trivial, since we are adding and subtracting the same vector to `u` on the right side. Also,\n"
"`(‚ü™u,v‚ü´ / (‚Äñv‚Äñ^2)) ‚Ä¢ v` is clearly a scalar multiple of `v`. The only thing we have to prove is that\n"
"`v` is orthogonal to `u - ((‚ü™u,v‚ü´ / (‚Äñv‚Äñ^2)) ‚Ä¢ v)`."
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "`ortho_decom` is a proof that given vectors `u v : V` and `h : v ‚â† 0`, then `orthogonal (u - (‚ü™u,v‚ü´ / (‚Äñv‚Äñ^2)) ‚Ä¢ v) v`.\n"
"This allows you to rewrite `u` as a scalar multiple of `v` added to a vector orthogonal to `v`."
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "Start by unfolding the definition of orthogonal."
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "Try `unfold orthogonal`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "Expand the inner product using linearity properties."
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "Try `rw[inner_minus_left, InnerProductSpace_v.inner_smul_left]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "Simplify the norm squared expression."
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "Try `unfold norm_v`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "Try `norm_cast`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "Try `rw[sq_sqrt (inner_self_nonneg v), ‚Üê inner_self_real]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "Use ring operations to simplify the algebra."
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "Try `ring_nf`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "The key step: cancel ‚ü™v,v‚ü´ in numerator and denominator."
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "Try `rw[mul_assoc, mul_inv_cancel]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "Try `simp`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "We need v ‚â† 0 to ensure ‚ü™v,v‚ü´ ‚â† 0 for cancellation."
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "Try `intro x`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level06
msgid "Try `exact h ((inner_self_eq_zero v).1 x)`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Cauchy-Schwarz Inequality"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "The Cauchy-Schwarz inequality is one of the most fundamental inequalities in mathematics. It states that for any two vectors `u` and `v` in an inner product space:\n"
"\n"
"$$|\\langle u, v \\rangle| \\leq \\|u\\| \\cdot \\|v\\|$$\n"
"\n"
"This inequality has deep geometric meaning: the absolute value of the inner product (which relates to the cosine of the angle between vectors) is bounded by the product of their lengths. This ensures that when we define angles using inner products, the cosine stays between -1 and 1.\n"
"\n"
"## The Goal\n"
"We prove this using orthogonal decomposition. The key insight is to decompose `u` relative to `v` as `u = c ‚Ä¢ v + w` where `w` is orthogonal to `v`. Then we use the Pythagorean theorem and algebraic manipulation to establish the inequality.\n"
"\n"
"## The Strategy\n"
"1. Handle the case `v = 0` separately (trivial)\n"
"2. For `v ‚â† 0`, use orthogonal decomposition: `u = c ‚Ä¢ v + w` with `w ‚ä• v`  \n"
"3. Apply Pythagorean theorem: `‚Äñu‚Äñ¬≤ = ‚Äñc ‚Ä¢ v‚Äñ¬≤ + ‚Äñw‚Äñ¬≤`\n"
"4. Since `‚Äñw‚Äñ¬≤ ‚â• 0`, we get `‚Äñu‚Äñ¬≤ ‚â• ‚Äñc ‚Ä¢ v‚Äñ¬≤`\n"
"5. Substitute `c = ‚ü™u,v‚ü´ / ‚Äñv‚Äñ¬≤` and algebraically simplify"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "The Cauchy-Schwarz inequality: `‚Äñ‚ü™u,v‚ü´‚Äñ ‚â§ ‚Äñu‚Äñ * ‚Äñv‚Äñ` for any vectors `u` and `v`.\n"
"This is one of the most important inequalities in linear algebra and analysis."
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "We need to consider two cases: when `v = 0` and when `v ‚â† 0`."
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `by_cases v_zero : v = 0`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "First, let's handle the case when `v = 0`. When `v = 0`, both sides become 0."
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `rw[v_zero]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `rw [inner_zero_right_v]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `have h := norm_zero_v (0:V)`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `simp at h`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `rw[h]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `simp`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Now for the main case where `v ‚â† 0`. We'll use orthogonal decomposition."
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "We'll decompose u as c‚Ä¢v + w where w is orthogonal to v."
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "The key insight: choose c = ‚ü™u,v‚ü´ / ‚Äñv‚Äñ¬≤ to make w orthogonal to v."
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `let c := ‚ü™u,v‚ü´ / (‚Äñv‚Äñ^2)`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `let w := u - c ‚Ä¢ v`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Now we establish the key properties of our decomposition."
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `have h3 : u = c ‚Ä¢ v + w := by simp [c, w]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "The orthogonality follows from our choice of c."
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `have h4 : orthogonal w v := ortho_decom u v v_zero`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `have h5:= left_smul_ortho v w c (ortho_swap w v h4)`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `have g3 : 0 ‚â§ ‚Äñu‚Äñ * ‚Äñv‚Äñ := mul_nonneg (norm_nonneg_v u) (norm_nonneg_v v)`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "We reduce to proving the squared version of the inequality."
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `suffices ‚Äñ‚ü™u,v‚ü´‚Äñ^2 ‚â§ ‚Äñu‚Äñ^2 * ‚Äñv‚Äñ^2 by exact le_of_sq_le_sq this g3`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `have ts : ‚Äñu‚Äñ^2 * ‚Äñv‚Äñ^2 = (‚Äñu‚Äñ * ‚Äñv‚Äñ)^2 := by ring`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `rw [ts] at this`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `exact le_of_sq_le_sq this g3`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Apply the Pythagorean theorem using orthogonality."
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `have h6 := pythagorean (c‚Ä¢ v) w h5`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `nth_rw 2 [h3]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `rw [h6]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `have v_norm_zero : ‚Äñv‚Äñ ‚â† 0 := by by_contra h; rw [norm_zero_v v] at h; contradiction`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "The crucial step: express ‚Äñc ‚Ä¢ v‚Äñ¬≤ in terms of the inner product."
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Since c = ‚ü™u,v‚ü´/‚Äñv‚Äñ¬≤, we get ‚Äñc ‚Ä¢ v‚Äñ¬≤ = ‚Äñ‚ü™u,v‚ü´‚Äñ¬≤/‚Äñv‚Äñ¬≤."
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Now substitute our expression for ‚Äñc ‚Ä¢ v‚Äñ¬≤."
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `rw [kt]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Distribute the multiplication and simplify fractions."
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `rw [add_mul]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `field_simp [v_norm_zero]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "The final step: ‚Äñw‚Äñ¬≤ ‚â• 0 always holds since norms are non-negative."
msgstr ""

#: Game.Levels.InnerProductWorld.Level07
msgid "Try `exact norm_sq_nonneg w`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "Triangle Inequality for the Norm"
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "## Triangle Inequality\n"
"\n"
"In any inner product space, the norm satisfies the triangle inequality:\n"
"$$\\|u+v\\| \\leq \\|u\\| + \\|v\\|$$\n"
"\n"
"Geometrically, this says the straight-line path is the shortest. In this level, you'll prove this fundamental result using the inner product, the Cauchy‚ÄìSchwarz inequality, and basic algebra.\n"
"\n"
"## Summary\n"
"The triangle inequality is a cornerstone of normed spaces. For any vectors $u$ and $v$, the straight-line distance ($\\|u+v\\|$) is never greater than the sum of the distances ($\\|u\\| + \\|v\\|$).\n"
"\n"
"## Key idea\n"
"- Expand $\\|u+v\\|^2$ using the inner product.\n"
"- Bound the cross term $2\\,\\Re\\,\\langle u,v\\rangle$ using the Cauchy‚ÄìSchwarz inequality.\n"
"- Finish by taking square roots, using nonnegativity of norm.\n"
"\n"
"This property is what makes $\\|\\cdot\\|$ a norm, ensuring our vector space is a metric space!"
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "The triangle inequality is a fundamental property of norms in inner product spaces.\n"
"It states that `‚Äñu+v‚Äñ ‚â§ ‚Äñu‚Äñ + ‚Äñv‚Äñ` for any vectors `u` and `v`.\n"
"This ensures that the norm defines a proper distance on the vector space."
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "It's easier to prove the squared version first."
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "Try `suffices ‚Äñu+v‚Äñ^2 ‚â§ (‚Äñu‚Äñ + ‚Äñv‚Äñ)^2 by exact le_of_sq_le_sq this (add_nonneg (norm_nonneg_v u) (norm_nonneg_v v))`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "Try `exact le_of_sq_le_sq this (add_nonneg (norm_nonneg_v u) (norm_nonneg_v v))`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "Expand using the inner product and apply Cauchy-Schwarz."
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "Try `rw [norm_sq_eq, add_sq, norm_sq_eq, norm_sq_eq]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "First expand the inner product ‚ü™u+v, u+v‚ü´ using linearity."
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "This will give us ‚ü™u,u‚ü´ + ‚ü™v,v‚ü´ + ‚ü™u,v‚ü´ + ‚ü™v,u‚ü´."
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "Try `have inner_expansion : ‚ü™u+v, u+v‚ü´.re = ‚ü™u,u‚ü´.re + ‚ü™v,v‚ü´.re + 2*‚ü™u,v‚ü´.re := by rw [InnerProductSpace_v.inner_add_left, inner_add_right_v, inner_add_right_v]; simp only [Complex.add_re]; rw [InnerProductSpace_v.inner_conj_symm v u, Complex.conj_re]; ring`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "Try `rw [inner_expansion]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "Now we bound the cross term 2*‚ü™u,v‚ü´.re using Cauchy-Schwarz."
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "We know |‚ü™u,v‚ü´| ‚â§ ‚Äñu‚Äñ * ‚Äñv‚Äñ, so ‚ü™u,v‚ü´.re ‚â§ ‚Äñu‚Äñ * ‚Äñv‚Äñ."
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "Try `have cross_bound : ‚ü™u,v‚ü´.re ‚â§ ‚Äñu‚Äñ * ‚Äñv‚Äñ := by have cs := Cauchy_Schwarz u v; rw [norm_inner_eq_abs] at cs; exact le_trans (re_le_abs ‚ü™u,v‚ü´) cs`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "Finally, use linear arithmetic to complete the proof."
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "Try `linarith [cross_bound]`"
msgstr ""

#: Game.Levels.InnerProductWorld.Level08
msgid "You have proven the triangle inequality!  \n"
"This key result guarantees that norm defines a 'distance' on the vector space."
msgstr ""

#: Game.Levels.InnerProductWorld
msgid "Inner Product World"
msgstr ""

#: Game.Levels.InnerProductWorld
msgid "Welcome to the Inner Product World! In this world, we introduce the idea of the inner product,\n"
"along with orthogonality and vector norms. You will prove many familiar theorems, such as the Pythagorean\n"
"Theorem and the Cauchy Schwarz Inequality."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level01
msgid "What is a Linear Map?"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level01
msgid "In this level, we introduce the fundamental concept of a **linear map** between vector spaces.\n"
"\n"
"## The Core Idea\n"
"\n"
"A linear map (also called a linear transformation) is a function between vector spaces that preserves the essential vector space operations: addition and scalar multiplication.\n"
"\n"
"## Mathematical Definition\n"
"\n"
"Given vector spaces $V$ and $W$ over a field $K$, a function $T : V \\to W$ is called linear if it satisfies these two properties:\n"
"\n"
"‚Ä¢ Additivity: $T(u + v) = T(u) + T(v)$ for all $u, v \\in V$\n"
"‚Ä¢ Homogeneity: $T(a \\cdot v) = a \\cdot T(v)$ for all $a \\in K$ and $v \\in V$\n"
"\n"
"## Why This Matters\n"
"\n"
"Linear maps are the structure-preserving functions of linear algebra. They respect the vector space structure, making them the natural morphisms between vector spaces.\n"
"\n"
"### Your Goal\n"
"Prove that our definition captures exactly these two fundamental properties. \n"
"\n"
"In Lean, we define `is_linear_map_v K V W T` (see Definitions panel) to formalize exactly what it means for a function T to be linear."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level01
msgid "`is_linear_map_v K V W T` means T preserves addition and scalar multiplication."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level01
msgid "A linear map preserves vector addition and scalar multiplication."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level01
msgid "The definition of a linear map is exactly additivity and homogeneity."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level01
msgid "Try unfold is_linear_map_v to see the definition directly."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level01
msgid "Try `unfold is_linear_map_v`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level01
msgid "Try `rfl`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level01
msgid "You have formalized the fundamental definition of a linear map.\n"
"\n"
"Linear maps are the backbone of linear algebra - they preserve the structure we care about. In the next levels, you'll explore what linear maps do to special sets like the null space and range."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level02
msgid "The Null Space"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level02
msgid "Now that we understand what linear maps are, let's explore one of their most important properties: the **null space**.\n"
"\n"
"## The Core Idea\n"
"\n"
"Given a linear map $T : V \\to W$, some vectors in $V$ get mapped to the zero vector in $W$. The collection of all such vectors forms what we call the **null space** (or kernel) of $T$.\n"
"\n"
"## Mathematical Definition\n"
"\n"
"The null space of a linear map $T : V \\to W$ is:\n"
"$$\\text{null } T = \\{v \\in V : T(v) = 0_W\\}$$\n"
"\n"
"### Your Goal\n"
"Prove that zero is always in the null space of any linear map."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level02
msgid "`null_space_v T` is the set of vectors that T maps to zero."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level02
msgid "Zero is always in the null space."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level02
msgid "Zero is always in the null space of any linear map."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level02
msgid "Unfold the definition of null_space_v and show T 0 = 0."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level02
msgid "Try `show T 0 = 0`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level02
msgid "Use the homogeneity property of linear maps with a = 0."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level02
msgid "Try `have h : T (0 ‚Ä¢ (0 : V)) = 0 ‚Ä¢ T 0 := hT.2 0 0`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level02
msgid "Simplify: 0 ‚Ä¢ v = 0 for any vector v."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level02
msgid "Try `simp at h`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level02
msgid "Try `exact h`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level02
msgid "You've proven that zero is always in the null space!\n"
"\n"
"This shows that the null space is never empty - it always contains at least the zero vector. This is the first step toward proving that the null space is a subspace."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level03
msgid "The Range"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level03
msgid "Now let's explore the other fundamental concept associated with linear maps: the **range**.\n"
"\n"
"## The Core Idea\n"
"\n"
"While the null space tells us which vectors get mapped to zero, the range tells us which vectors can be reached as outputs of the linear map.\n"
"\n"
"## Mathematical Definition\n"
"\n"
"The range of a linear map $T : V \\to W$ is:\n"
"$$\\text{range } T = \\{w \\in W : \\exists v \\in V, T(v) = w\\}$$\n"
"\n"
"## Why This Matters\n"
"\n"
"The range describes the 'image' or 'output space' of the linear map. Together with the null space, it gives us complete information about what the linear map does.\n"
"\n"
"### Your Goal\n"
"Prove that if $T$ maps $v$ to $w$, then $w$ is in the range of $T$."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level03
msgid "`range_v K V W T` is the set of all possible outputs of T."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level03
msgid "Images are in the range."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level03
msgid "If T maps v to w, then w is in the range of T."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level03
msgid "Show there exists some vector that T maps to w."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level03
msgid "Try `show ‚àÉ u : V, T u = w`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level03
msgid "Use v as the witness and apply hypothesis h."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level03
msgid "Try `use v, h`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level03
msgid "You've proven that outputs of T are always in its range!\n"
"\n"
"This establishes the basic relationship between a linear map and its range. The range captures exactly those vectors that can be 'reached' by applying T to some input."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level04
msgid "Linear Maps Preserve Zero"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level04
msgid "Now let's prove a fundamental property that every linear map must satisfy: they always map the zero vector to the zero vector.\n"
"\n"
"## The Key Insight\n"
"\n"
"This might seem obvious, but it's an important consequence of linearity that we'll use in many future proofs.\n"
"\n"
"## Why This Matters\n"
"\n"
"The fact that linear maps preserve zero is often the first step in proving that the null space is non-empty, and it's crucial for understanding the structure of linear maps.\n"
"\n"
"### Your Goal\n"
"Prove that for any linear map T, we have T(0) = 0."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level04
msgid "Linear maps preserve zero."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level04
msgid "Every linear map maps the zero vector to the zero vector."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level04
msgid "Use the homogeneity property with scalar 0. Apply hT.2 with scalar 0 and vector 0."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level04
msgid "Try `have h : T (0 ‚Ä¢ (0 : V)) = 0 ‚Ä¢ T 0 := hT.2 0 0`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level04
msgid "Simplify: 0 ‚Ä¢ v = 0 for any vector v. Use simp to clean up the zeros."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level04
msgid "Try `simp at h`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level04
msgid "Now h gives us exactly what we need: T 0 = 0."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level04
msgid "Try `exact h`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level04
msgid "You've proven that linear maps always preserve zero!\n"
"\n"
"This simple but fundamental property will be the foundation for many more sophisticated results about linear maps. Every linear map, no matter how complex, must map 0 to 0."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "The Range is a Subspace"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "Just as we proved that the null space is always a subspace, we'll now prove that the range is also always a subspace.\n"
"\n"
"## The Key Insight\n"
"\n"
"The range of a linear map T : V ‚Üí W is a subspace of the codomain W. This means we can apply all our subspace theory to understand the image of any linear map.\n"
"\n"
"## Why This Matters\n"
"\n"
"This result, combined with our null space theorem, shows that linear maps have a very structured behavior - both their 'input kernel' and 'output image' are subspaces.\n"
"\n"
"## Proof Strategy\n"
"\n"
"We need to verify the three subspace properties:\n"
"1. **Non-empty**: The range contains 0 (since T(0) = 0)\n"
"2. **Closed under addition**: If w‚ÇÅ, w‚ÇÇ are in the range, so is w‚ÇÅ + w‚ÇÇ\n"
"3. **Closed under scalar multiplication**: If w is in the range and a is a scalar, then a‚Ä¢w is in the range\n"
"\n"
"### Your Goal\n"
"Prove that the range of any linear map is a subspace."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "The range of a linear map is a subspace."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "The range of any linear map is a subspace of the codomain."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "We need to verify the three subspace properties."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "First, show the range is non-empty by proving 0 is in it."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "Try `use 0`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "Try `use 0`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "Try `have h := hT.2 (0 : K) (0 : V)`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "Try `simp only [zero_smul, smul_zero] at h`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "Try `exact h`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "For closure under addition, if w‚ÇÅ = T(v‚ÇÅ) and w‚ÇÇ = T(v‚ÇÇ), then w‚ÇÅ + w‚ÇÇ = T(v‚ÇÅ + v‚ÇÇ)."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "Try `intro w1 w2 hw1 hw2`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "Try `obtain ‚ü®v1, hv1‚ü© := hw1`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "Try `obtain ‚ü®v2, hv2‚ü© := hw2`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "Try `use v1 + v2`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "Try `rw [hT.1 v1 v2, hv1, hv2]`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "For scalar multiplication, if w = T(v), then a‚Ä¢w = T(a‚Ä¢v)."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "Try `intro a w hw`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "Try `obtain ‚ü®v, hv‚ü© := hw`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "Try `use a ‚Ä¢ v`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "Try `rw [hT.2 a v, hv]`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level05
msgid "You've proven that the range is always a subspace!\n"
"\n"
"Now we know that both the null space and range of any linear map are subspaces. This gives us powerful tools for analyzing the structure and behavior of linear transformations."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level06
msgid "Linear Maps Preserve Linear Combinations"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level06
msgid "Now we'll prove that linear maps preserve not just addition and scalar multiplication, but any linear combination.\n"
"\n"
"## The Key Insight\n"
"\n"
"If we have vectors v‚ÇÅ, v‚ÇÇ and scalars a‚ÇÅ, a‚ÇÇ, then:\n"
"T(a‚ÇÅ ‚Ä¢ v‚ÇÅ + a‚ÇÇ ‚Ä¢ v‚ÇÇ) = a‚ÇÅ ‚Ä¢ T(v‚ÇÅ) + a‚ÇÇ ‚Ä¢ T(v‚ÇÇ)\n"
"\n"
"This shows that linear maps preserve the fundamental operation of linear algebra: taking linear combinations.\n"
"\n"
"## Strategy\n"
"\n"
"This proof uses both defining properties of linear maps:\n"
"1. **Additivity**: T(u + v) = T(u) + T(v) - to split the sum\n"
"2. **Homogeneity**: T(a ‚Ä¢ v) = a ‚Ä¢ T(v) - to factor out scalars\n"
"\n"
"## Why This Matters\n"
"\n"
"This property is what makes linear maps so powerful - they preserve all the structure we care about in linear algebra. Any relationship expressed as a linear combination in the domain is preserved in the codomain.\n"
"\n"
"### Your Goal\n"
"Prove that linear maps preserve linear combinations of two vectors."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level06
msgid "Linear maps preserve linear combinations."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level06
msgid "Linear maps preserve linear combinations of two vectors."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level06
msgid "Use additivity to split T(a‚ÇÅ ‚Ä¢ v‚ÇÅ + a‚ÇÇ ‚Ä¢ v‚ÇÇ). The additivity property says T(u + v) = T(u) + T(v)."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level06
msgid "Try `rw [hT.1 (a1 ‚Ä¢ v1) (a2 ‚Ä¢ v2)]`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level06
msgid "Now use homogeneity on each term. The homogeneity property says T(a ‚Ä¢ v) = a ‚Ä¢ T(v)."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level06
msgid "Try `rw [hT.2 a1 v1, hT.2 a2 v2]`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level06
msgid "You've proven that linear maps preserve linear combinations!\n"
"\n"
"This is a fundamental property that captures the essence of what makes a map 'linear' - it preserves the basic operations of linear algebra. This result can be extended to any finite linear combination."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "Surjective Linear Maps"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "In our final level of LinearMapsWorld, we'll introduce the concept of surjectivity and prove a basic property.\n"
"\n"
"## The Core Idea\n"
"\n"
"A linear map is surjective (onto) if every element in the codomain can be reached. In other words, the range equals the entire codomain.\n"
"\n"
"## Mathematical Definition\n"
"\n"
"A linear map $T : V \\to W$ is surjective if:\n"
"$$\\text{range } T = W$$\n"
"\n"
"This is equivalent to saying: for every $w \\in W$, there exists $v \\in V$ such that $T(v) = w$.\n"
"\n"
"## Why This Matters\n"
"\n"
"Surjectivity tells us when a linear map 'fills up' its target space completely. Combined with injectivity, it characterizes when linear maps are invertible.\n"
"\n"
"### Your Goal\n"
"Prove that if T is surjective, then every element of W is in the range of T."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "`surjective_v K V W T` means T is onto."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "Surjectivity means range equals codomain."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "If T is surjective, then every element of W is in the range of T."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "Show both directions of the equivalence. A ‚Üî B means we need to prove both A ‚Üí B and B ‚Üí A."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "First direction: if T is surjective, then every w is in the range. We assume surjectivity and show any w ‚àà W is in the range."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "Introduce the surjectivity hypothesis and an arbitrary element w ‚àà W."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "Try `intro h_surj w`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "Since T is surjective, by definition there exists v such that T v = w. Use the surjectivity hypothesis directly."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "Try `exact h_surj w`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "Second direction: if every w is in the range, then T is surjective. We assume every w is in the range and show surjectivity."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "Introduce the range hypothesis and an arbitrary element w ‚àà W to show surjectivity."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "Try `intro h_range w`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "The range hypothesis gives us exactly what we need - that w ‚àà range means ‚àÉ v, T v = w."
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "Try `exact h_range w`"
msgstr ""

#: Game.Levels.LinearMapsWorld.Level07
msgid "You've connected surjectivity with the range!\n"
"\n"
"You've now learned the fundamental concepts of linear maps: definition, null space, range, and the basic properties they satisfy. These form the foundation for understanding more advanced topics like the rank-nullity theorem and isomorphisms.\n"
"\n"
"Congratulations on completing LinearMapsWorld!"
msgstr ""

#: Game.Levels.LinearMapsWorld
msgid "Linear Maps World"
msgstr ""

#: Game.Levels.LinearMapsWorld
msgid "Welcome to Linear Maps World! This world will introduce you to formalizing proofs about linear maps\n"
"in Lean. This world includes proofs about bases and dimension, for example if a subspace has the same\n"
"dimension as the whole space, it is the whole space."
msgstr ""

#: Game
msgid "Linear Algebra Game"
msgstr ""

#: Game
msgid "# Welcome to the Linear Algebra Game!\n"
"\n"
"This game works as a learning tool for linear algebra,\n"
"based on the textbook \"Linear Algebra Done Right\" by Sheldon Axler. It also serves as an\n"
"introduction to Lean 4, a proof assistant that provides an environment to encode proofs formally.\n"
"\n"
"Proofs in Lean can are written in precise syntax, using tactics and theorems, and can be algorithmically\n"
"checked for correctness by a computer.\n"
"\n"
"This game covers many areas of linear algebra, including vector spaces, linear independence, bases,\n"
"linear mappings, and isomorphisms.\n"
"\n"
"To start, click on \"Tutorial World\""
msgstr ""

#: Game
msgid "*Game version: 1.0*\n"
"\n"
"## Progress saving\n"
"\n"
"The game stores your progress in your local browser storage.\n"
"If you delete it, your progress will be lost!\n"
"\n"
"Warning: In most browsers, deleting cookies will also clear the local storage\n"
"(or \"local site data\"). Make sure to download your game progress first!\n"
"\n"
"## Credits\n"
"\n"
"* **Team:** Huiyu Chen, Adam Kern, Justin Morrill, and Letian Yang\n"
"* **Project Manager:** Daniel Zhou\n"
"* **Project Leader:** Professor Colleen Robles\n"
"* **2023 Lean 3 Version:** Yannan Bai, Annapurna Bhattacharya, Chun-Hsien Hsu, Stavan Jain, Kurt Ma, Ricardo Prado Cunha, Anoushka Sinha (Project Manager: Chun-Hsien Hsu)\n"
"* **Game Engine:** Alexander Bentkamp, Jon Eugster, Patrick Massot\n"
"* **Inspiration:** Kevin Buzzard's Natural Number Game (https://adam.math.hhu.de/#/g/leanprover-community/nng4)"
msgstr ""

#: Game
msgid "Game Template"
msgstr ""

#: Game
msgid "You should use this game as a template for your own game and add your own levels."
msgstr ""
