msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Mon Jun 16 19:14:19 2025\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "The rfl tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "## Summary\n"
"\n"
"`rfl` proves goals of the form `X = X`.\n"
"\n"
"In other words, the `rfl` tactic will close any goal of the\n"
"form `A = B` if `A` and `B` are *identical*.\n"
"\n"
"`rfl` is short for \\\"reflexivity (of equality)\\\".\n"
"\n"
"## Example:\n"
"\n"
"If the goal looks like this:\n"
"\n"
"```\n"
"x + 37 = x + 37\n"
"```\n"
"\n"
"then `rfl` will close it. But if it looks like `0 + x = x` then `rfl` won't work, because even\n"
"though $0+x$ and $x$ are always equal as *numbers*, they are not equal as *terms*.\n"
"The only term which is identical to `0 + x` is `0 + x`.\n"
"\n"
"## Details\n"
"\n"
"`rfl` is short for \\\"reflexivity of equality\\\"."
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "Most levels in this game will require you to prove a mathematical theorem. In the middle of the\n"
"screen, you will see your \"Active Goal\", which includes \"Objects:\" `x: ‚Ñù` and a \"Goal\" `x=x`.\n"
"In later levels, you may also get a \"Assumptions\" line. Your objects and assumptions are what you\n"
"have to work with. In this case, we know that `x` is in  `‚Ñù`, which means `x` is a real number.\n"
"From this, we have to prove our goal, that `x=x`.\n"
"\n"
"The first tactic we will use is the `rfl` tactic. `rfl` stands for \"reflexivity\". `rfl` will solve\n"
"goals when the left side of an equation is the same as the right side, at least up to definitions."
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "Try typing 'rfl' into the text box below, then hit \"Execute\". This should finish the proof."
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "You have now finished your first proof in Lean 4! In future levels, you can also use the 'rfl' tactic.\n"
"You can click on the 'rfl' box on the right side to learn more about the 'rfl' tactic.\n"
"\n"
"Click on \"Next\" to go to the next level."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "The rewrite (rw) tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "## Summary\n"
"\n"
"If `h` is a proof of an equality `X = Y`, then `rw [h]` will change\n"
"all `X`s in the goal to `Y`s. It's the way to \\\"substitute in\\\".\n"
"\n"
"## Variants\n"
"\n"
"* `rw [‚Üê h]` (changes `Y`s to `X`s; get the back arrow by typing `\\left ` or `\\l`.)\n"
"\n"
"* `rw [h1, h2]` (a sequence of rewrites)\n"
"\n"
"* `rw [h] at h2` (changes `X`s to `Y`s in hypothesis `h2`)\n"
"\n"
"* `rw [h] at h1 h2 ‚ä¢` (changes `X`s to `Y`s in two hypotheses and the goal;\n"
"get the `‚ä¢` symbol with `\\|-`.)\n"
"\n"
"* `repeat rw [add_zero]` will keep changing `? + 0` to `?`\n"
"until there are no more matches for `? + 0`.\n"
"\n"
"* `nth_rewrite 2 [h]` will change only the second `X` in the goal to `Y`.\n"
"\n"
"### Example:\n"
"\n"
"If you have the assumption `h : x = y + y` and your goal is\n"
"```\n"
"succ (x + 0) = succ (y + y)\n"
"```\n"
"\n"
"then\n"
"\n"
"`rw [add_zero]`\n"
"\n"
"will change the goal into `succ x = succ (y + y)`, and then\n"
"\n"
"`rw [h]`\n"
"\n"
"will change the goal into `succ (y + y) = succ (y + y)`, which\n"
"can be solved with `rfl`.\n"
"\n"
"### Example:\n"
"\n"
"You can use `rw` to change a hypothesis as well.\n"
"For example, if you have two hypotheses\n"
"```\n"
"h1 : x = y + 3\n"
"h2 : 2 * y = x\n"
"```\n"
"then `rw [h1] at h2` will turn `h2` into `h2 : 2 * y = y + 3`.\n"
"\n"
"## Common errors\n"
"\n"
"* You need the square brackets. `rw h` is never correct.\n"
"\n"
"* If `h` is not a *proof* of an *equality* (a statement of the form `A = B`),\n"
"for example if `h` is a function or an implication,\n"
"then `rw` is not the tactic you want to use. For example,\n"
"`rw [P = Q]` is never correct: `P = Q` is the theorem *statement*,\n"
"not the proof. If `h : P = Q` is the proof, then `rw [h]` will work.\n"
"\n"
"## Details\n"
"\n"
"The `rw` tactic is a way to do \\\"substituting in\\\". There\n"
"are two distinct situations where you can use this tactic.\n"
"\n"
"1) Basic usage: if `h : A = B` is an assumption or\n"
"the proof of a theorem, and if the goal contains one or more `A`s, then `rw [h]`\n"
"will change them all to `B`s. The tactic will error\n"
"if there are no `A`s in the goal.\n"
"\n"
"2) Advanced usage: Assumptions coming from theorem proofs\n"
"often have missing pieces. For example `add_zero`\n"
"is a proof that `? + 0 = ?` because `add_zero` really is a function,\n"
"and `?` is the input. In this situation `rw` will look through the goal\n"
"for any subterm of the form `x + 0`, and the moment it\n"
"finds one it fixes `?` to be `x` then changes all `x + 0`s to `x`s.\n"
"\n"
"Exercise: think about why `rw [add_zero]` changes the term\n"
"`(0 + 0) + (x + 0) + (0 + 0) + (x + 0)` to\n"
"`0 + (x + 0) + 0 + (x + 0)`\n"
"\n"
"If you can't remember the name of the proof of an equality, look it up in\n"
"the list of lemmas on the right.\n"
"\n"
"## Targeted usage\n"
"\n"
"If your goal is `b + c + a = b + (a + c)` and you want to rewrite `a + c`\n"
"to `c + a`, then `rw [add_comm]` will not work because Lean finds another\n"
"addition first and swaps those inputs instead. Use `rw [add_comm a c]` to\n"
"guarantee that Lean rewrites `a + c` to `c + a`. This works because\n"
"`add_comm` is a proof that `?1 + ?2 = ?2 + ?1`, `add_comm a` is a proof\n"
"that `a + ? = ? + a`, and `add_comm a c` is a proof that `a + c = c + a`.\n"
"\n"
"If `h : X = Y` then `rw [h]` will turn all `X`s into `Y`s.\n"
"If you only want to change the 37th occurrence of `X`\n"
"to `Y` then do `nth_rewrite 37 [h]`."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "## Summary\n"
"\n"
"`repeat t` repeatedly applies the tactic `t`\n"
"to the goal. You don't need to use this\n"
"tactic, it just speeds things up sometimes.\n"
"\n"
"## Example\n"
"\n"
"`repeat rw [add_zero]` will turn the goal\n"
"`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\n"
"into the goal\n"
"`a = b`.\n"
"\"\n"
"\n"
"TacticDoc nth_rewrite \"\n"
"## Summary\n"
"\n"
"If `h : X = Y` and there are several `X`s in the goal, then\n"
"`nth_rewrite 3 [h]` will just change the third `X` to a `Y`.\n"
"\n"
"## Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `nth_rewrite 2 [two_eq_succ_one]`\n"
"will change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\n"
"will change the goal to `succ 1 + succ 1 = 4`."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "## Summary\n"
"\n"
"If `h : X = Y` and there are several `X`s in the goal, then\n"
"`nth_rewrite 3 [h]` will just change the third `X` to a `Y`.\n"
"\n"
"## Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `nth_rewrite 2 [two_eq_succ_one]`\n"
"will change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\n"
"will change the goal to `succ 1 + succ 1 = 4`."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "The second tactic we will look at is the rewrite tactic. This tactic is how you \"substitute in\"\n"
"a value for something you know is equal. If you have an assumption `h: A=B`, and your goal is to\n"
"prove something about `A`, you can replace `A` with `B`, since they are equal.\n"
"\n"
"In this level, the goal is to prove `2 * y = 2 * (x + 7)`. You also have an assumption `h: y = x + 7`.\n"
"Writing `rw[h]` will rewrite `y` as `x + 7` in the goal.\n"
"\n"
"Also note that the `rw` tactic will automatically attempt the `rfl` tactic after it rewrites, so if\n"
"after the rewrite the goal is of the form `X = X`, it will automatically be solved."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "Try using `rw [h]` to solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "You now know the two most basic tactics in Lean! Again, you can click on `rw` on the right hand side\n"
"to see more about the tactic.\n"
"\n"
"Click on \"Next\" to go to the next level!"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "The `intro` and `exact` tactics"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "## Summary\n"
"\n"
"Intro introduces a new hypothesis and changes your goal. If you have a goal of the form `P ‚Üí Q`,\n"
"`intro h` will change the goal to `Q` and create a new hypothesis `h : P`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `x = 1 ‚Üí x + x = 2`, `intro h` will create the hypothesis `h: x = 1`, and change the\n"
"goal to `x + x = 2`.\n"
"\n"
"## Other usage\n"
"\n"
"The `intro` tactic also works with goals using `‚àÄ` (\\\"for all\\\"). If your goal is of the form `‚àÄ x : T, P`,\n"
"`intro x` will create a new variable `x : T`, and change the goal to `P`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `‚àÄ x : Nat, x ‚â• 0`, `intro x` will create a variable `x : Nat`, and change the goal\n"
"to `x ‚â• 0`."
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "## Summary\n"
"\n"
"If the goal is a statement `P`, then `exact h` will solve the goal if `h` is a proof of `P`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `x + 5 = 10`, and you have a hypothesis `h: x + 5 = 10`, then `exact h` will solve\n"
"the goal.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `x ‚¨ù y = 0 ‚Üî x ‚üÇ y`, and you have a theorem `dot_zero_iff_perp` that states the same\n"
"thing, `exact dot_zero_iff_perp` will solve the goal.\n"
"\n"
"## exact? tactic\n"
"\n"
"`exact` has a variation, `exact?`, that is very useful. If your goal seems very obvious, and if you\n"
"believe that there is a theorem or hypothesis that is exactly the same as your goal, `exact?` will\n"
"attempt to fill in an `exact` tactic. This way, you don't have to memorize the exact statement of\n"
"every theorem in order to finish a proof.\n"
"However, with great power comes great responsibility, and using `exact?` too often can obscure how\n"
"a proof actually works, and can lead you to being more confused than when you started."
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "In this level, we will introduce two tactics: `intro`, and `exact`\n"
"Our goal is to prove that for any proposition (a True/False statement) `P`, we know that `P ‚Üí P`.\n"
"This means that `P` implies `P`.\n"
"\n"
"To explain what implication means more rigorously, if we know that `P ‚Üí Q`, whenever `P` is True, we\n"
"now know that `Q` must also be True. A computer scientist can consider a proof that `P ‚Üí Q` as a function\n"
"taking proofs of `P` to proofs of `Q`. In Lean, this means that we take an arbitrary proof of `P`,\n"
"say `h: P` and we must construct a proof of `Q` from it.\n"
"\n"
"### Intro\n"
"This idea is exatly what the `intro` tactic does. If the goal is of the form `P ‚Üí Q`, `intro h` will\n"
"create a new hypothesis `h: P`, and change the goal into `Q`.\n"
"\n"
"### Exact\n"
"The exact tactic is the other tactic you will need to solve this level. If you have a hypothesis that\n"
"is exactly the same as the goal, the exact tactic will solve the goal. For example, if your goal is\n"
"`P`, and you have a hypothesis `h: P`, `exact h` will solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "First use `intro` to give yourself a new assumption and simplify the goal"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "Now use `exact` to solve the goal"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "You now know how to use the `intro` and `exact` tactics!"
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "The `constructor` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "## Summary\n"
"\n"
"The constructor tactic splits the goal into multiple parts. This is helpful for goals that are\n"
"difficult to solve all at once, like \"and\" (`‚àß`) and \"if and only if\" (`‚Üî`).\n"
"\n"
"## Example\n"
"\n"
"If we have the goal `P ‚àß Q`, `constructor` will change the goal into two goals: `P` and `Q`.\n"
"\n"
"## Example\n"
"\n"
"If we have the goal`P ‚Üî Q`, `constructor` will change the goal into two goals: `P ‚Üí Q`, and `Q ‚Üí P`."
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "In this level we will learn `constructor` in the context of logical 'and' (‚àß).\n"
"Our goal is to prove `P ‚àß Q`, \"P and Q\", given hypotheses `p: P` and `q: Q`.\n"
"\n"
"### Constructor:\n"
"\n"
"The `constructor` tactic works by splitting up the goal. If you have a goal `P ‚àß Q`, the tactic makes\n"
"progress by turning this one goal into two goals: to prove `P` and to prove `Q`. Constructor also\n"
"works similarly for `‚Üî` \"if and only if\" goals."
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "Try using `constructor` to split up the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "Both remaining goals are exactly your hypotheses. What tactic can solve the goals?"
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "You can now prove goals by splitting them into multiple steps with the `constructor` tactic!"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "The `unfold` and `apply` tactics"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "## Summary\n"
"\n"
"If we have some object or function with some definition, `unfold object` will rewrite the object\n"
"with its definition everywhere. Lean often unfolds terms automatically, but some tactics and definitions\n"
"are not unfolded automatically. The `unfold` tactic also helps make it easier to take the next steps.\n"
"\n"
"## Example:\n"
"\n"
"If you have a goal `(P ‚Üí Q) ‚Üí (¬¨ Q ‚Üí ¬¨ P)`, with `¬¨ P` (\\\"Not\\\" P) being defined as `P ‚Üí False`,\n"
"using `unfold Not` will change the goal to `(P ‚Üí Q) ‚Üí ((Q ‚Üí False) ‚Üí (P ‚Üí False))`"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "## Summary\n"
"\n"
"If `t : P ‚Üí Q` is a proof that $P \\implies Q$, and `h : P` is a proof of `P`,\n"
"then `apply t at h` will change `h` to a proof of `Q`. The idea is that if\n"
"you know `P` is true, then you can deduce from `t` that `Q` is true.\n"
"\n"
"If the *goal* is `Q`, then `apply t` will \\\"argue backwards\\\" and change the\n"
"goal to `P`. The idea here is that if you want to prove `Q`, then by `t`\n"
"it suffices to prove `P`, so you can reduce the goal to proving `P`.\n"
"\n"
"### Example:\n"
"\n"
"`succ_inj x y` is a proof that `succ x = succ y ‚Üí x = y`.\n"
"\n"
"So if you have a hypothesis `h : succ (a + 37) = succ (b + 42)`\n"
"then `apply succ_inj at h` will change `h` to `a + 37 = b + 42`.\n"
"You could write `apply succ_inj (a + 37) (b + 42) at h`\n"
"but Lean is smart enough to figure out the inputs to `succ_inj`.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `a * b = 7`, then `apply succ_inj` will turn the\n"
"goal into `succ (a * b) = succ 7`."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "## Summary\n"
"\n"
"`intros` acts very similar to the `intro` tactic, except it allows you to introduce many new\n"
"hypotheses/variables at once. `intros h1 h2 h3` essentially acts as `intro h1; intro h2; intro h3;`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `P ‚Üí Q ‚Üí (‚àÄ x : Nat, R ‚Üí (x = 5))`, `intros p q x r` will create hypotheses `p: P`,\n"
"`q: Q`, `r: R`, and a variable `x: Nat`, and change the goal to `x = 5`."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "In this level, we will learn the `unfold` and `apply` tactics. Our goal is to prove `(P ‚Üí Q) ‚Üí (¬¨ Q ‚Üí ¬¨ P)`,\n"
"which looks very messy and difficult, but it can be slowly unfolded and broken down into simple steps.\n"
"\n"
"The first tactic we will need is `unfold`. You may notice the `¬¨` symbol appearing multiple times in\n"
"the goal. This symbol means \"Not\", so `¬¨P` means \"not P\", or that P is false. In Lean, this is\n"
"encoded as `P ‚Üí False`.\n"
"\n"
"### Unfold\n"
"The `unfold` tactic will unfold definitions. Think of it as a big `rw` tactic that rewrites something\n"
"with it's definition everywhere. In this level, `unfold Not` will replace all the `¬¨ P`s with `P ‚Üí False`.\n"
"\n"
"We know how to deal with statements of the form `P ‚Üí Q` in the goal, but what happens if we have them\n"
"as hypotheses? In this case, we will need the `apply` tactic.\n"
"\n"
"### Apply\n"
"The `apply` tactic applies a hypothesis of the form `P ‚Üí Q` to the goal. If your goal is `Q`, and\n"
"you have a hypothesis `h: P ‚Üí Q`, `apply h` will change the goal to `P`.\n"
"\n"
"### Combining hypotheses\n"
"Another way to use `h: P ‚Üí Q` hypotheses is that if you also have another hypothesis  `h2: P`,\n"
"`h h2` will be a proof of `Q`. So, if you have these two hypotheses, and your goal is `Q`, `exact h h2`\n"
"will solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Try using `unfold Not` to unfold the definition of `¬¨`."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Now, since there is a hypothesis also with a `¬¨` symbol, `unfold Not at *` will unfold\n"
"everywhere!"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Now, since you goal is of the form `P ‚Üí Q`, the `intro` tactic may help."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "You can still use the `intro` tactic because the goal is still of the form `P ‚Üí Q`"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Now, try the `apply` tactic. Remember that if your goal is `Q`, you can use `apply h` when\n"
"h is a hypothesis or proof that `P ‚Üí Q`. You can also solve the level with one carefully worded\n"
"`exact` statement if you combine your hypotheses."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Again, try the `apply` tactic to change the goal. You can also solve the level with one carefully worded\n"
"`exact` statement if you combine your hypotheses."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "This theorem shows that a statement `P ‚Üí Q` implies its contrapositive `¬¨Q ‚Üí ¬¨P`. In fact, these\n"
"two statements are the same, and you can prove `(P ‚Üí Q) ‚Üî (¬¨ Q ‚Üí ¬¨ P)`\n"
"\n"
"Also, instead of writing intro three times, you can write `intros h1 h2 h3`, and that will be the\n"
"same as `intro h1; intro h2; intro h3`."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "The `cases'` and `exfalso` tactics"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "## Summary\n"
"\n"
"If `h` is a proof (for example a hypothesis), then `cases' h with...` will break the\n"
"proof up into the pieces used to prove it.\n"
"\n"
"## Example\n"
"\n"
"If `h : P ‚à® Q` is a hypothesis, then `cases' h with hp hq` will turn one goal\n"
"into two goals, one with a hypothesis `hp : P` and the other with a\n"
"hypothesis `hq : Q`.\n"
"\n"
"## Example\n"
"\n"
"If `h : False` is a hypothesis, then `cases' h` will turn one goal into no goals,\n"
"because there are no ways to make a proof of `False`! And if you have no goals left,\n"
"you have finished the level.\n"
"\n"
"\n"
"## Example\n"
"\n"
"If `h : ‚àÉ (a : ‚Ñù), a * a = 0` is a hypothesis, thatn `cases' h with a ha` will create a variable\n"
"`a : Nat` and a hypothesis `ha : a * a = 0`"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "## Summary\n"
"\n"
"`exfalso` changes any goal to `False` this works because proving `False` is a contradiction and can\n"
"thus prove anything else. Mathematically, this means that for any proposition `P`, `False ‚Üí P`.\n"
"\n"
"## Example\n"
"\n"
"If you have a hypothesis `h: False`, and a goal `Q`, `exfalso; exact h` will solve the goal`"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "This level introduces the `cases'` and `exfalso` tactics. The goal of this level is to prove `(P ‚àß ¬¨ P) ‚Üí Q`.\n"
"This proof is similar to a proof by contradiction. The first part of the implication, `P ‚àß ¬¨ P`, is\n"
"a contradiction, so it can prove any proposition `Q`.\n"
"\n"
"### Cases'\n"
"The `cases'` tactic is very important in Lean. It allows you to split any object or hypothesis into\n"
"cases. In this level, we will eventually have an and statement as a hypothesis. If we have `h: P ‚àß Q`,\n"
"`cases' h with hL hR` will create two hypotheses: `hL: P`, and `hR: Q`. If you have an object `x` that\n"
"can be split into cases, `cases' x with c1 c2` will split `x` into cases called `c1` and `c2`.\n"
"\n"
"### Exfalso\n"
"The `exfalso` tactic is also useful in this level. It simply changes the goal to `False`. This works\n"
"because if you can prove `False`, you have a contradiction, and can thus prove any statements. For\n"
"example, if you have a hypothesis `h: False`, and a goal `Q`, `exfalso; exact h` will solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "You have two main options here. Note that you have a statement of the form `P ‚Üí Q`, so there\n"
"is a tactic we know that can simplify the goal. Also, we have a `¬¨` character, so unfolding that\n"
"could also be helpful"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "Since the `¬¨` symbol is in a hypothesis now, instead of the goal, in order to unfold it you\n"
"need to do `unfold Not at h`, where you replace `h` with the name of your hypothesis. `unfold Not\n"
"at *` will also unfold it everywhere."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "Now, use the `cases'` tactic to split up your and statement hypothesis."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "It would be nice if our goal was `False` here."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "You now know most of the basics for working with logic in Lean! The remaining levels in the tutorial\n"
"world will move away from pure logic, but many of the tactics used already will still be essential."
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "The `linarith` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "## Summary\n"
"The `linarith` tactic simplifies the goal by using the hypotheses. It works well on linear inequalities\n"
"and equalities. It works by looking for contradictions, although the actual algorithmic implementation\n"
"is very complicated.\n"
"\n"
"## Example\n"
"\n"
"If you have a bunch of hypotheses like h1 : a < b, h2 : b <= c, h3 : c = d and a goal of a < d,\n"
"then linarith will solve it. Linarith knows how to combine linear relations: it knows a ton of\n"
"results about how to put inequalities together and will close such goals."
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "The `linarith` tactic aims to simplify the process of proofs. Specifically, it solves certain kinds\n"
"of linear equalities and inequalities. It attempts to solve or simplify the goal using the hypotheses\n"
"and certain properties of the numbers you are working with."
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "In this level, simply trying `linarith` should solve the level."
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "Linarith is very useful to simplify goals involving linear terms."
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "The `simp` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "### Summary\n"
"\n"
"The `simp` tactic tries to simplify the goal, and will solve it if possible. It acts similar to the\n"
"`rw` tactic, although it is able to rewrite with many different statements many times in order to\n"
"simplify the goal. `simp` will try to use all the theorems available if not told explicitly what\n"
"theorems to use.\n"
"\n"
"Using `simp only [tactic1, tactic2, ...]` will simplify only using the theorems listed.\n"
"\n"
"### Example\n"
"\n"
"If your goal is something simple like `0 + 0 = 0`, `simp` will know enough about the natural numbers\n"
"to solve the goal.\n"
"\n"
"### Example\n"
"\n"
"If your goal is `(d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h`, which seems\n"
"complicated, but you only need to use associativity and commutativity of addition,\n"
"`simp only [add_assoc, add_left_comm, add_comm]` will solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "The `simp` tactic aims to simplify your goal. Often if a goal seems very complicated, or uses\n"
"definitions that need to be unfolded, the `simp` tactic will make progress.\n"
"\n"
"`simp` is not a flawless tool, and there are many simple statements it cannot prove, although when\n"
"used correctly, it can be very useful.\n"
"\n"
"In this level, your goal is to prove an equality about certain elements in a \"Group\". A group is a\n"
"mathematical object where elements in a group can be multiplied together in a way that \"makes sense\".\n"
"Examples of groups involve the real numbers, integers, invertible square matrices of a specific size,\n"
"and many more. `simp` knows many theorems about groups, and is able to simplify and solve most\n"
"simple statements about them.\n"
"\n"
"In this level, `a b c` are all elements of G, `1` is the multiplicative identity of G, and `a‚Åª¬π` is\n"
"the multiplicative inverse of `a`. You can see that both sides of the equation will cancel out to `b`,\n"
"but there is an easy way to prove that they are equal."
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "Just typing `simp` will solve the goal"
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "`simp` will be very useful when solving simple equations in future worlds. You can always\n"
"read more about it by clicking on it on the right."
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "The `use` tactic and your first theorem"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "## Summary\n"
"\n"
"The `use` tactic makes progress with goals which claim something *exists*.\n"
"If the goal claims that some `x` exists with some property, and you know\n"
"that `x = 37` will work, then `use 37` will make progress.\n"
"\n"
"Because `a ‚â§ b` is notation for \\\"there exists `c` such that `b = a + c`\\\",\n"
"you can make progress on goals of the form `a ‚â§ b` by `use`ing the\n"
"number which is morally `b - a` (i.e. `use b - a`)\n"
"\n"
"Any of the following examples is possible assuming the type of the argument passed to the `use` function is accurate:\n"
"\n"
"- `use 37`\n"
"- `use a`\n"
"- `use a * a + 1`"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "le_iff_exists_add is a proof that `a ‚â§ b ‚Üî ‚àÉ (c : ‚Ñï), a = b + c`.\n"
"\n"
"The reason for the name is that two numbers are less than or equal to each other if and only if\n"
"there exists a number that you can add to the smaller one to make them equal."
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "In this level, the goal is to prove `x ‚â§ 1 + x`. This requires understanding how to prove statements\n"
"about inequalities. We can define the `‚â§` symbol so that `a ‚â§ b` means `‚àÉ (c : ‚Ñï), b = a + c`. In\n"
"other words, a is less than or equal to b if and only if there exists a natural number c where\n"
"b = a + c. In this level, we have decided to use the natural numbers, although the statement is\n"
"clearly also true when working with real numbers. This is because the theorem \"le_iff_exists_add\"\n"
"does not work with the real numbers, so the proof would be slightly different.\n"
"\n"
"We have this statment as a theorem, \"le_iff_exists_add\".\n"
"\n"
"However, note that this theorem will rewrite the goal to have a `‚àÉ` symbol. In this case, we have to\n"
"find a number that satisfies a certain property. Once you find such a number, you can use the `use`\n"
"tactic.\n"
"\n"
"`use c` changes the goal from the form `‚àÉ x, Property(x)` to `Property(c)`. This allows you to solve\n"
"`‚àÉ` goals, but you need to first find a valid example, which may take some planing ahead."
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "Try using the new theorem! Since it is a proof of `‚Üî`, the rewrite tactic should work!"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "What number should you use here to make the statement true?"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "You now have a simple linear equation. What tactic can solve linear equations and prove\n"
"equalities?"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "Now on to the last level in the tutorial world!"
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "The `induction'` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "## Summary\n"
"\n"
"If `n : ‚Ñï` is an object, and the goal mentions `n`, then `induction' n with d hd`\n"
"attempts to prove the goal by induction on `n`, with the inductive\n"
"variable in the successor case being `d`, and the inductive hypothesis being `hd`.\n"
"\n"
"### Example:\n"
"If the goal is\n"
"```\n"
"0 + n = n\n"
"```\n"
"\n"
"then\n"
"\n"
"`induction' n with d hd`\n"
"\n"
"will turn it into two goals. The first is `0 + 0 = 0`;\n"
"the second has an assumption `hd : 0 + d = d` and goal\n"
"`0 + succ d = succ d`.\n"
"\n"
"Note that you must prove the first\n"
"goal before you can access the second one."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "'add_succ' is a proof that `n + Nat.succ m = Nat.succ (n + m)`.\n"
"\n"
"The reason for the name is that the theorem proves that adding the successor of a number is equal to\n"
"the successor of addind that number."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "The `induction'` tactic is a powerful tool to help you to prove statments involving natural numbers.\n"
"It splits a proof into two cases: a base case and an inductive step. The base case is the smallest\n"
"natural number you need to prove the proof for. The inductive step proves the theorem for all other\n"
"numbers. In the inductive step, you can assume the theorem holds for some value `d`, and must then\n"
"prove that it holds for `d + 1`, also written as `Nat.succ d`, the successor of `d`. Induction can\n"
"also be used to prove theorems about objects indexed my natural numbers, such as vectors whose\n"
"dimension can be described by a natural number.\n"
"\n"
"The syntax for the `induction'` tactic is `induction' n with d hd`. As long as `n` is an arbirtary\n"
"natural number in the proof, this will do induction on `n`, where `d` is the number you assume the\n"
"theorem holds for in the inductive step, and `hd` is the induction hypothesis you will get.\n"
"\n"
"This level also uses a new theorem: `add_succ`. `add_succ` is a proof that\n"
"`n + Nat.succ m = Nat.succ (n + m)`, for any `n, m : ‚Ñï`."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "First, perform induction on `n`."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "Now, for the base case, you need to prove a simple property of the naturals."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "You are adding the successor of a number here, try to simplify this using the new theorem!"
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "Now, use the inductive hypothesis to finish the proof!"
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "## Summary\n"
"You have now finished Tutorial World! Now, you can move on to Vector Space world.\n"
"\n"
"The future worlds will be more challenging than this one, and will use less hints. However, if you're\n"
"stuck on how a tactic or theorem works, you can always read what they do on the right, or return to\n"
"Tutorial World for more review!\n"
"\n"
"Click \"Leave World\" to return to the main menu."
msgstr ""

#: Game.Levels.TutorialWorld
msgid "Tutorial World"
msgstr ""

#: Game.Levels.TutorialWorld
msgid "Welcome to the tutorial world! This world is designed to indroduce you to Lean 4.\n"
"\n"
"In this world, we start with proving 'x=x', and then move on to solve basic logic problems and\n"
"simple theorems about the natural numbers.\n"
"\n"
"If you already know how to use Lean 4, you can skip this world, although we recommend playing through it.\n"
"\n"
"Click start to begin solving your first level!"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "Vector space intro, zero scalar multiplication"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "## Summary\n"
"The `symm` tactic stands for symmetry of equality. It shows that if we know `a = b`, then `b = a`.\n"
"\n"
"## Example\n"
"If your goal is `a = b`, `symm` will change the goal to `b = a`.\n"
"\n"
"## Example\n"
"If you have a hypothesis `h: a = b`, `symm at h` will change the hypothesis to `h: b = a`.\n"
"\n"
"## Example\n"
"If you have a theorem `add_dist: ‚àÄ a b c, (a + b) * c = a * c + b * c`, and a goal `2 * x + 5 * x = y`,\n"
"`rw[(add_dist 2 5 x).symm]` will change the goal to `(2 + 5) * x = y`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "## Vector Space Definition\n"
"\n"
"We begin by defining a vector space over a field `K` with an abelian group `V`. This class includes four key axioms:\n"
"\n"
"```\n"
"class VectorSpace (K V : Type) [Field K] [AddCommGroup V] extends SMul K V where\n"
"  smul_add : ‚àÄ (a : K) (x y : V), a ‚Ä¢ (x + y) = a ‚Ä¢ x + a ‚Ä¢ y           -- distributivity of scalar over vector addition\n"
"  add_smul : ‚àÄ (a b : K) (x : V), (a + b) ‚Ä¢ x = a ‚Ä¢ x + b ‚Ä¢ x           -- distributivity of scalar addition\n"
"  mul_smul : ‚àÄ (a b : K) (x : V), (a * b) ‚Ä¢ x = a ‚Ä¢ (b ‚Ä¢ x)             -- compatibility of scalar multiplication\n"
"  one_smul : ‚àÄ (x : V), (1 : K) ‚Ä¢ x = x                                -- identity scalar acts as identity\n"
"```\n"
"\n"
"This foundational structure will be used throughout all future levels. No proof is needed here\n"
"‚Äî just understand the axioms and how they're represented. Note that to write the `‚Ä¢` character, type\n"
"\"\\smul\"\n"
"\n"
"## Goal for this level\n"
"\n"
"In this level, you'll prove that multiplying a vector by the zero scalar (`0 : K`) results in the\n"
"zero vector (`0 : V`). This is going to be a slightly involved proof, so it is important to get an\n"
"understanding of the proof before beginning to write it.\n"
"\n"
"The first step of a normal proof would be writing `0 ‚Ä¢ w` as `(0 + 0) ‚Ä¢ w`, then using distributivity\n"
"to get it as `0 ‚Ä¢ w + 0 ‚Ä¢ w`. Lastly, cancelling out a `0 ‚Ä¢ w` on each side gets `0 = 0 ‚Ä¢ w`.\n"
"\n"
"However, this proof relies on our assumptions and constructs the goal from them. This can be done in\n"
"Lean, however, it requires using the `have` tactic, and is unnescessarily complex. In Lean, proofs are\n"
"often done backwards, working from the goal and creating the hypotheses.\n"
"\n"
"Doing the proof backwards thus must first involve adding `0 ‚Ä¢ w` to both sides of the goal, undoing\n"
"distributivity, then cancelling out some zeros.\n"
"\n"
"### add_right_cancel\n"
"\n"
"To use cancellation of addition, we need a new theorem, `add_right_cancel`. This theorem is a proof\n"
"that `a + b = c + b ‚Üí a = c`. Since your goal is of the form `a = c`, `apply add_right_cancel` will\n"
"change the goal to `a + ?b = c + ?b`. However, you want to be able to write the value of `?b`, but\n"
"in this case, Lean doesn't know what value you want to add. You can tell Lean what to add to the\n"
"equation by `apply add_right_cancel (b := ????)`, replacing the question marks with whatever you\n"
"want to add.\n"
"\n"
"### symm\n"
"\n"
"You will also need the `symm` tactic. `symm` stands for symmetry of equality, and it can be used to\n"
"change goals of the form `a = b` to `b = a`. `symm at h` will also change a hypothesis `h: a = b` to\n"
"`h: b = a`. However, neither of these uses are needed in this level. You may\n"
"notice that if `h: a = b` is a hypothesis, rw[h] will rewrite all `a`s to `b`s. What if you want to\n"
"rewrite all `b`s to `a`s, you can instead do `rw[h.symm]`.\n"
"\n"
"Also note that when the theorem has a `‚àÄ` symbol, as in `‚àÄ a b : S, a + b = b + a`, you need to\n"
"specify what `a` and `b` you mean to use before using `.symm`. For example, you would have to write\n"
"`rw[(h 2 3).symm]`.\n"
"\n"
"One last hint is that when writing `0`, you often want to specify which zero you are talking about.\n"
"We know that the natural numbers, for example, has a `0`, but so do the Field K and the Abelian Group\n"
"V, and those `0`s are different. To specify which `0` you are talking about, write `(0 : K)` or `(0 : V)`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "A vector space is a space over a field K with an abelian group V. It has four main properties:\n"
"- Distributivity over vector addition,\n"
"- Distributivity over scalar addition,\n"
"- Associativity of scalar multiplication,\n"
"- Identity scalar acting as identity.\n"
"\n"
"These properties can be found in the theorems tab as \"smul_add\", \"add_smul\", \"mul_smul\", and \"one_smul\"."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "This is a proof that `0 ‚Ä¢ w = 0`, or that scaling any vector by `0` gives the zero vector.\n"
"\n"
"It is called \"zero_smul_v\", since you perform scalar multiplication by zero. The \"v\" means that it is\n"
"scalar multiplication of a vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "`add_right_cancel` is a proof that `a + b = c + b ‚Üí a = c`. You can tell Lean what to add to the\n"
"equation by `apply add_right_cancel (b := ????)`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "`smul_add` is one of the axioms of a vector space. It is a proof that if we know `vs : VectorSpace K V`,\n"
"then `‚àÄ (a : K) (x y : V), a ‚Ä¢ (x + y) = a ‚Ä¢ x + a ‚Ä¢ y`. It can be considered as right distributivity\n"
"of scalar multiplication"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "`add_smul` is one of the axioms of a vector space. It is a proof that if we know `vs : VectorSpace K V`,\n"
"then `‚àÄ (a b : K) (x : V), (a + b) ‚Ä¢ x = a ‚Ä¢ x + b ‚Ä¢ x`. It can be considered as left distributivity\n"
"of scalar multiplication."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "‚àÄ (a b : K) (x : V), (a * b) ‚Ä¢ x = a ‚Ä¢ (b ‚Ä¢ x)\n"
"`mul_smul` is one of the axioms of a vector space. It is a proof that if we know `vs : VectorSpace K V`,\n"
"then `‚àÄ (a b : K) (x : V), (a * b) ‚Ä¢ x = a ‚Ä¢ (b ‚Ä¢ x)`. It can be considered as associativity of scalar\n"
"multiplication."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "`one_smul` is one of the axioms of a vector space. It is a proof that if we know `vs : VectorSpace K V`,\n"
"then `‚àÄ (x : V), (1 : K) ‚Ä¢ x = x`. It can be thought of as `1` being a multiplicative identity not\n"
"only in `K`, but also through scalar multiplication in `V`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "This is just so Lean doesn't get mad at me for having `symm` as a tactic when it is considered a theorem."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "In any vector space V over K, the scalar 0 multiplied by any vector gives the zero vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "Remember, we are trying to prove this backwards. The last step in the normal proof was to\n"
"cancel out 0 ‚Ä¢ w from both sides, so what should the first step of the backwards proof be?"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "Try `apply add_right_cancel (b := (0 : K) ‚Ä¢ w)`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "Now, there is a theorem we have from the vector space definition that can change the left\n"
"side of the equation. Think about the second to last step in the normal proof. You may also need to\n"
"use `.symm` here."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "Try `rw[(add_smul (0 : K) (0 : K) w).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "Now, we just have to cancel out zeros. You can prove this using some theorems, or there is a\n"
"tactic we have already learned that can simplify everything and close the goal."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "Try `simp`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "You have now proven your first theorem about vector spaces! One note: if you want to use\n"
"one of the theorems you prove in one level in another level, the syntax will be\n"
"`theorem_name fk acg vs theorem_args`. This is because we take as hypotheses in each level that\n"
"K is a Field, V is an abelian group, and K V is a vector space. To use a theorem, we need to include\n"
"proofs of those statements."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Multiplying by the zero vector"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "We just proved that multiplying by the zero scalar gives the zero vector. Now, we will\n"
"show that multiplying by the zero vector also gives the zero vector.\n"
"\n"
"The proof is very similar to the last level, and requires no new tactics.\n"
"\n"
"Again, first think out the proof yourself (pencil and paper may help), then reverse the proof and\n"
"write it in lean. You can also look at the previous level for inspiration and syntax help."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "This is a proof that `a ‚Ä¢ 0 = 0`, or that scaling the zero vector by any scalar gives the zero vector.\n"
"\n"
"It is called \"smul_zero_v\", since you perform scalar multiplication by the zero vector. The \"v\" means that it is\n"
"scalar multiplication of a vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "In any vector space V over K, any scalar a multiplied by the zero vector gives the zero vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Try `apply add_right_cancel (b := a ‚Ä¢ (0 : V))`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Try `rw[(smul_add a (0 : V) (0 : V)).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Try `simp`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Scaling by -1"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "This is a proof that `-1 ‚Ä¢ v = -v`, that multiplying by the -1 scalar gives the inverse vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "We now understand scaling by `0` very well. We also have an axiom that scaling by `1`\n"
"acts as the identity. The next step is to see what scaling by `-1` does. Intuitively, it should\n"
"cancel out the vector scaled by `1`, so it should be the additive inverse of the vector.\n"
"\n"
"The goal of the level is to prove this.\n"
"\n"
"A few hints that could help:\n"
"The defining property of `-v` is that `-v + v = 0`. The `simp` tactic can use this. Try to use this\n"
"in your proof.\n"
"You can also use the theorems proven in previous levels.\n"
"\n"
"### Strange error with `(one_smul v).symm`\n"
"You may eventually try to rewrite a vector `v` as `1 ‚Ä¢ v` in this level. However, trying\n"
"`rw[(one_smul v).symm]` may run into errors. This is because `one_smul v` only takes an element of `V`\n"
"as input, so Lean doesn't know which field \"K\" to use to get the \"1\" from. To fix this, try\n"
"`one_smul (K := K) v` to tell Lean which \"K\" you are using."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "In any vector space V over K, multiplying a vector by -1 gives its additive inverse."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "A good first step is cancelling out the `-v` term on the right."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Try `apply add_right_cancel (b := v)`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Try `simp`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Remember the `nth_rw m [theorem]` tactic to only rewrite the mth instance."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Try `nth_rw 2 [(one_smul (K := K) v).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Try `rw[(add_smul (-1 : K) (1 : K) v).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Try `simp`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "This looks like something we've done before. Either the `rw` or `exact` tactics should solve the goal"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Try `rw [zero_smul_v]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "We now have many theorems relating to vector spaces! In the next levels, we will introduce\n"
"the idea of a \"subspace\"."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Zero must belong"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Now that we understand what a vector space is, and have proven a simple theorem about\n"
"them, let's define what a subspace is. Intuitively, a subspace is a subset of a vector space that\n"
"can be considered as a vector space itself. We define this as a subset `W : Set V` that is nonempty,\n"
"is closed under addition, and is closed under scalar multiplication.\n"
"\n"
"### The `obtain` tactic\n"
"A new tactic will help us solve problems with subspaces. While not necessary, and this tactic can\n"
"even be completely replaced by the `cases'` tactic, it will simplify your proofs greatly. The `obtain`\n"
"tactic essentially acts as repeating `cases'`. In this level, it has two main uses. First, if `hw : isSubspace W`\n"
"is a hypothesis, then `obtain ‚ü®h1, h2, h3‚ü© := hW` will split the definition into the three parts,\n"
"labeled h1, h2, and h3. The other important use for `obtain` is if you have a hypothesis `hW : W.Nonempty`,\n"
"then `obtain ‚ü®w, hw‚ü© := hW` will give you a `w : V`, and a hypothesis `hw : w ‚àà W`. Also, the \"‚ü®\"\n"
"character is written with \"\\langle\", and the \"‚ü©\" character is written with \"\\rangle\".\n"
"\n"
"### Subspace contains zero\n"
"One of the basic properties of a subspace is that it must be nonempty. In fact, every subspace must\n"
"contain the zero vector. This is because for any vector in a subspace, you can multiply it by the zero\n"
"scalar while still remaining in the subspace, which wil result in the zero vector. In this level, we\n"
"formally prove this result."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "A subspace is a subset of a vector space that acts similarly to a vector space itself. It has three\n"
"main properties:\n"
"- Nonempty: a subspace cannot be empty\n"
"- Closure under addition: adding any two elements of a subspace should remain in that subspace\n"
"- Closure under scalar multiplication: scaling any vector in a subspace should remanin in that subspace\n"
"\n"
"Subspaces are formalized by having the `isSubspace` proposition, which simply combines the three\n"
"properties into one proposition."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "## Summary\n"
"The `obtain` tactic works very similar to repeating the `cases'` tactic. The `obtain` tactic splits a\n"
"statement into cases, and allows you to name each case. Instead of splitting into two cases, like the\n"
"`cases'` tactic, `obtain` can split into as many cases as necessary. The syntax looks like\n"
"`obtain ‚ü®h1, h2, h3‚ü© := h`.\n"
"\n"
"## Example\n"
"If `hw : isSubspace W` is a hypothesis, then `obtain ‚ü®h1, h2, h3‚ü© := hW` will split the definition\n"
"into three parts, labeled h1, h2, and h3.\n"
"\n"
"## Example\n"
"If you have a hypothesis `hW : W.Nonempty`, where `W : Set V` is a subset of `V`, then\n"
"`obtain ‚ü®w, hw‚ü© := hW` will give you a `w : V`, and a hypothesis `hw : w ‚àà W`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "This is a proof that any subspace contains the zero vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "This is a proof that any subspace contains the zero vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try to expand out your hypotheses using `obtain`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try `obtain ‚ü®h1, h2, h3‚ü© := hW`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Again, you can use `obtain` to simplify a hypothesis."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try `obtain ‚ü®w, hw‚ü© := ¬´{h1}¬ª`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "We know that `0 ‚Ä¢ ¬´{w}¬ª ‚àà W`. If this was our goal, the level would be easy to solve. Also,\n"
"remember that if you have to use a theorem you have proven in a previous level, you have to write\n"
"`theorem_name fk acg vs theorem_args` to show Lean that K V is a vector space."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try `rw [(zero_smul_v fk acg vs ¬´{w}¬ª).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Now, apply the fact that subspaces are closed under scalar multiplication."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try `apply ¬´{h3}¬ª`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try `exact ¬´{hw}¬ª`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Negatives in Subspace"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "The last theorem we will prove in Vector Space World is that subspaces contain the additive inverses\n"
"of each of their elements. The proof is very similar to the previous level. You can try to solve it\n"
"completely on your own, and if you get stuck, you can always press the \"Show more help!\" button to\n"
"get the next step."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "This is a proof that if a subspace contains a vector `x`, it also contains `-x`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Try `obtain ‚ü®h1, h2, h3‚ü© := hW`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Try `obtain ‚ü®h1, h2, h3‚ü© := hW`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Try `intros x hx`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Try `rw [(neg_one_smul_v fk acg vs ¬´{x}¬ª).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Try `apply ¬´{h3}¬ª`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Try `exact ¬´{hx}¬ª`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "You have now completed Vector Space World! The theorems proven here will be very helpful\n"
"in future worlds. You can now move on to World 2: Linear Independence and Span World!"
msgstr ""

#: Game.Levels.VectorSpaceWorld
msgid "Vector Space World"
msgstr ""

#: Game.Levels.VectorSpaceWorld
msgid "Welcome to Vector Space World! In this world, you'll build up the basic theory of vector spaces\n"
"through formal proofs in Lean."
msgstr ""

#: Game
msgid "Linear Algebra Game"
msgstr ""

#: Game
msgid "# Welcome to the Linear Algebra Game!\n"
"\n"
"This game works as a learning tool for linear algebra,\n"
"based on the textbook \"Linear Algebra Done Right\" by Sheldon Axler. It also serves as an\n"
"introduction to Lean 4, a proof assistant that provides an environment to encode proofs formally.\n"
"\n"
"Proofs in Lean can are written in precise syntax, using tactics and theorems, and can be algorithmically\n"
"checked for correctness by a computer.\n"
"\n"
"This game covers many areas of linear algebra, including vector spaces, linear independence, bases,\n"
"linear mappings, and isomorphisms.\n"
"\n"
"To start, click on \"Tutorial World\""
msgstr ""

#: Game
msgid "*Game version: 1.0*\n"
"\n"
"## Progress saving\n"
"\n"
"The game stores your progress in your local browser storage.\n"
"If you delete it, your progress will be lost!\n"
"\n"
"Warning: In most browsers, deleting cookies will also clear the local storage\n"
"(or \"local site data\"). Make sure to download your game progress first!\n"
"\n"
"## Credits\n"
"\n"
"* **Team:** Huiyu Chen, Adam Kern, Justin Morrill, and Letian Yang\n"
"* **Project Manager:** Daniel Zhou\n"
"* **Project Leader:** Professor Colleen Robles\n"
"* **2023 Lean 3 Version:** Yannan Bai, Annapurna Bhattacharya, Chun-Hsien Hsu, Stavan Jain, Kurt Ma, Ricardo Prado Cunha, Anoushka Sinha\n"
"* **Game Engine:** Alexander Bentkamp, Jon Eugster, Patrick Massot\n"
"* **Inspiration:** Kevin Buzzard's Natural Number Game (https://adam.math.hhu.de/#/g/leanprover-community/nng4)"
msgstr ""

#: Game
msgid "Game Template"
msgstr ""

#: Game
msgid "You should use this game as a template for your own game and add your own levels."
msgstr ""
